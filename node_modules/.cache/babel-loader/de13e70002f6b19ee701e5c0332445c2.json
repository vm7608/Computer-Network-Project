{"ast":null,"code":"// Replace link-like texts with link nodes.\n//\n// Currently restricted by `inline.validateLink()` to http/https/ftp\n//\n'use strict';\n\nvar Autolinker = require('autolinker');\n\nvar LINK_SCAN_RE = /www|@|\\:\\/\\//;\n\nfunction isLinkOpen(str) {\n  return /^<a[>\\s]/i.test(str);\n}\n\nfunction isLinkClose(str) {\n  return /^<\\/a\\s*>/i.test(str);\n} // Stupid fabric to avoid singletons, for thread safety.\n// Required for engines like Nashorn.\n//\n\n\nfunction createLinkifier() {\n  var links = [];\n  var autolinker = new Autolinker({\n    stripPrefix: false,\n    url: true,\n    email: true,\n    twitter: false,\n    replaceFn: function (linker, match) {\n      // Only collect matched strings but don't change anything.\n      switch (match.getType()) {\n        /*eslint default-case:0*/\n        case 'url':\n          links.push({\n            text: match.matchedText,\n            url: match.getUrl()\n          });\n          break;\n\n        case 'email':\n          links.push({\n            text: match.matchedText,\n            // normalize email protocol\n            url: 'mailto:' + match.getEmail().replace(/^mailto:/i, '')\n          });\n          break;\n      }\n\n      return false;\n    }\n  });\n  return {\n    links: links,\n    autolinker: autolinker\n  };\n}\n\nmodule.exports = function linkify(state) {\n  var i,\n      j,\n      l,\n      tokens,\n      token,\n      text,\n      nodes,\n      ln,\n      pos,\n      level,\n      htmlLinkLevel,\n      blockTokens = state.tokens,\n      linkifier = null,\n      links,\n      autolinker;\n\n  if (!state.options.linkify) {\n    return;\n  }\n\n  for (j = 0, l = blockTokens.length; j < l; j++) {\n    if (blockTokens[j].type !== 'inline') {\n      continue;\n    }\n\n    tokens = blockTokens[j].children;\n    htmlLinkLevel = 0; // We scan from the end, to keep position when new tags added.\n    // Use reversed logic in links start/end match\n\n    for (i = tokens.length - 1; i >= 0; i--) {\n      token = tokens[i]; // Skip content of markdown links\n\n      if (token.type === 'link_close') {\n        i--;\n\n        while (tokens[i].level !== token.level && tokens[i].type !== 'link_open') {\n          i--;\n        }\n\n        continue;\n      } // Skip content of html tag links\n\n\n      if (token.type === 'htmltag') {\n        if (isLinkOpen(token.content) && htmlLinkLevel > 0) {\n          htmlLinkLevel--;\n        }\n\n        if (isLinkClose(token.content)) {\n          htmlLinkLevel++;\n        }\n      }\n\n      if (htmlLinkLevel > 0) {\n        continue;\n      }\n\n      if (token.type === 'text' && LINK_SCAN_RE.test(token.content)) {\n        // Init linkifier in lazy manner, only if required.\n        if (!linkifier) {\n          linkifier = createLinkifier();\n          links = linkifier.links;\n          autolinker = linkifier.autolinker;\n        }\n\n        text = token.content;\n        links.length = 0;\n        autolinker.link(text);\n\n        if (!links.length) {\n          continue;\n        } // Now split string to nodes\n\n\n        nodes = [];\n        level = token.level;\n\n        for (ln = 0; ln < links.length; ln++) {\n          if (!state.inline.validateLink(links[ln].url)) {\n            continue;\n          }\n\n          pos = text.indexOf(links[ln].text);\n\n          if (pos) {\n            level = level;\n            nodes.push({\n              type: 'text',\n              content: text.slice(0, pos),\n              level: level\n            });\n          }\n\n          nodes.push({\n            type: 'link_open',\n            href: links[ln].url,\n            title: '',\n            level: level++\n          });\n          nodes.push({\n            type: 'text',\n            content: links[ln].text,\n            level: level\n          });\n          nodes.push({\n            type: 'link_close',\n            level: --level\n          });\n          text = text.slice(pos + links[ln].text.length);\n        }\n\n        if (text.length) {\n          nodes.push({\n            type: 'text',\n            content: text,\n            level: level\n          });\n        } // replace current node\n\n\n        blockTokens[j].children = tokens = [].concat(tokens.slice(0, i), nodes, tokens.slice(i + 1));\n      }\n    }\n  }\n};","map":{"version":3,"names":["Autolinker","require","LINK_SCAN_RE","isLinkOpen","str","test","isLinkClose","createLinkifier","links","autolinker","stripPrefix","url","email","twitter","replaceFn","linker","match","getType","push","text","matchedText","getUrl","getEmail","replace","module","exports","linkify","state","i","j","l","tokens","token","nodes","ln","pos","level","htmlLinkLevel","blockTokens","linkifier","options","length","type","children","content","link","inline","validateLink","indexOf","slice","href","title","concat"],"sources":["C:/Users/caoma/Downloads/another/online-shop/node_modules/remarkable/lib/rules_core/linkify.js"],"sourcesContent":["// Replace link-like texts with link nodes.\n//\n// Currently restricted by `inline.validateLink()` to http/https/ftp\n//\n'use strict';\n\n\nvar Autolinker = require('autolinker');\n\n\nvar LINK_SCAN_RE = /www|@|\\:\\/\\//;\n\n\nfunction isLinkOpen(str) {\n  return /^<a[>\\s]/i.test(str);\n}\nfunction isLinkClose(str) {\n  return /^<\\/a\\s*>/i.test(str);\n}\n\n// Stupid fabric to avoid singletons, for thread safety.\n// Required for engines like Nashorn.\n//\nfunction createLinkifier() {\n  var links = [];\n  var autolinker = new Autolinker({\n    stripPrefix: false,\n    url: true,\n    email: true,\n    twitter: false,\n    replaceFn: function (linker, match) {\n      // Only collect matched strings but don't change anything.\n      switch (match.getType()) {\n        /*eslint default-case:0*/\n        case 'url':\n          links.push({\n            text: match.matchedText,\n            url: match.getUrl()\n          });\n          break;\n        case 'email':\n          links.push({\n            text: match.matchedText,\n            // normalize email protocol\n            url: 'mailto:' + match.getEmail().replace(/^mailto:/i, '')\n          });\n          break;\n      }\n      return false;\n    }\n  });\n\n  return {\n    links: links,\n    autolinker: autolinker\n  };\n}\n\n\nmodule.exports = function linkify(state) {\n  var i, j, l, tokens, token, text, nodes, ln, pos, level, htmlLinkLevel,\n      blockTokens = state.tokens,\n      linkifier = null, links, autolinker;\n\n  if (!state.options.linkify) { return; }\n\n  for (j = 0, l = blockTokens.length; j < l; j++) {\n    if (blockTokens[j].type !== 'inline') { continue; }\n    tokens = blockTokens[j].children;\n\n    htmlLinkLevel = 0;\n\n    // We scan from the end, to keep position when new tags added.\n    // Use reversed logic in links start/end match\n    for (i = tokens.length - 1; i >= 0; i--) {\n      token = tokens[i];\n\n      // Skip content of markdown links\n      if (token.type === 'link_close') {\n        i--;\n        while (tokens[i].level !== token.level && tokens[i].type !== 'link_open') {\n          i--;\n        }\n        continue;\n      }\n\n      // Skip content of html tag links\n      if (token.type === 'htmltag') {\n        if (isLinkOpen(token.content) && htmlLinkLevel > 0) {\n          htmlLinkLevel--;\n        }\n        if (isLinkClose(token.content)) {\n          htmlLinkLevel++;\n        }\n      }\n      if (htmlLinkLevel > 0) { continue; }\n\n      if (token.type === 'text' && LINK_SCAN_RE.test(token.content)) {\n\n        // Init linkifier in lazy manner, only if required.\n        if (!linkifier) {\n          linkifier = createLinkifier();\n          links = linkifier.links;\n          autolinker = linkifier.autolinker;\n        }\n\n        text = token.content;\n        links.length = 0;\n        autolinker.link(text);\n\n        if (!links.length) { continue; }\n\n        // Now split string to nodes\n        nodes = [];\n        level = token.level;\n\n        for (ln = 0; ln < links.length; ln++) {\n\n          if (!state.inline.validateLink(links[ln].url)) { continue; }\n\n          pos = text.indexOf(links[ln].text);\n\n          if (pos) {\n            level = level;\n            nodes.push({\n              type: 'text',\n              content: text.slice(0, pos),\n              level: level\n            });\n          }\n          nodes.push({\n            type: 'link_open',\n            href: links[ln].url,\n            title: '',\n            level: level++\n          });\n          nodes.push({\n            type: 'text',\n            content: links[ln].text,\n            level: level\n          });\n          nodes.push({\n            type: 'link_close',\n            level: --level\n          });\n          text = text.slice(pos + links[ln].text.length);\n        }\n        if (text.length) {\n          nodes.push({\n            type: 'text',\n            content: text,\n            level: level\n          });\n        }\n\n        // replace current node\n        blockTokens[j].children = tokens = [].concat(tokens.slice(0, i), nodes, tokens.slice(i + 1));\n      }\n    }\n  }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAGA,IAAIA,UAAU,GAAGC,OAAO,CAAC,YAAD,CAAxB;;AAGA,IAAIC,YAAY,GAAG,cAAnB;;AAGA,SAASC,UAAT,CAAoBC,GAApB,EAAyB;EACvB,OAAO,YAAYC,IAAZ,CAAiBD,GAAjB,CAAP;AACD;;AACD,SAASE,WAAT,CAAqBF,GAArB,EAA0B;EACxB,OAAO,aAAaC,IAAb,CAAkBD,GAAlB,CAAP;AACD,C,CAED;AACA;AACA;;;AACA,SAASG,eAAT,GAA2B;EACzB,IAAIC,KAAK,GAAG,EAAZ;EACA,IAAIC,UAAU,GAAG,IAAIT,UAAJ,CAAe;IAC9BU,WAAW,EAAE,KADiB;IAE9BC,GAAG,EAAE,IAFyB;IAG9BC,KAAK,EAAE,IAHuB;IAI9BC,OAAO,EAAE,KAJqB;IAK9BC,SAAS,EAAE,UAAUC,MAAV,EAAkBC,KAAlB,EAAyB;MAClC;MACA,QAAQA,KAAK,CAACC,OAAN,EAAR;QACE;QACA,KAAK,KAAL;UACET,KAAK,CAACU,IAAN,CAAW;YACTC,IAAI,EAAEH,KAAK,CAACI,WADH;YAETT,GAAG,EAAEK,KAAK,CAACK,MAAN;UAFI,CAAX;UAIA;;QACF,KAAK,OAAL;UACEb,KAAK,CAACU,IAAN,CAAW;YACTC,IAAI,EAAEH,KAAK,CAACI,WADH;YAET;YACAT,GAAG,EAAE,YAAYK,KAAK,CAACM,QAAN,GAAiBC,OAAjB,CAAyB,WAAzB,EAAsC,EAAtC;UAHR,CAAX;UAKA;MAdJ;;MAgBA,OAAO,KAAP;IACD;EAxB6B,CAAf,CAAjB;EA2BA,OAAO;IACLf,KAAK,EAAEA,KADF;IAELC,UAAU,EAAEA;EAFP,CAAP;AAID;;AAGDe,MAAM,CAACC,OAAP,GAAiB,SAASC,OAAT,CAAiBC,KAAjB,EAAwB;EACvC,IAAIC,CAAJ;EAAA,IAAOC,CAAP;EAAA,IAAUC,CAAV;EAAA,IAAaC,MAAb;EAAA,IAAqBC,KAArB;EAAA,IAA4Bb,IAA5B;EAAA,IAAkCc,KAAlC;EAAA,IAAyCC,EAAzC;EAAA,IAA6CC,GAA7C;EAAA,IAAkDC,KAAlD;EAAA,IAAyDC,aAAzD;EAAA,IACIC,WAAW,GAAGX,KAAK,CAACI,MADxB;EAAA,IAEIQ,SAAS,GAAG,IAFhB;EAAA,IAEsB/B,KAFtB;EAAA,IAE6BC,UAF7B;;EAIA,IAAI,CAACkB,KAAK,CAACa,OAAN,CAAcd,OAAnB,EAA4B;IAAE;EAAS;;EAEvC,KAAKG,CAAC,GAAG,CAAJ,EAAOC,CAAC,GAAGQ,WAAW,CAACG,MAA5B,EAAoCZ,CAAC,GAAGC,CAAxC,EAA2CD,CAAC,EAA5C,EAAgD;IAC9C,IAAIS,WAAW,CAACT,CAAD,CAAX,CAAea,IAAf,KAAwB,QAA5B,EAAsC;MAAE;IAAW;;IACnDX,MAAM,GAAGO,WAAW,CAACT,CAAD,CAAX,CAAec,QAAxB;IAEAN,aAAa,GAAG,CAAhB,CAJ8C,CAM9C;IACA;;IACA,KAAKT,CAAC,GAAGG,MAAM,CAACU,MAAP,GAAgB,CAAzB,EAA4Bb,CAAC,IAAI,CAAjC,EAAoCA,CAAC,EAArC,EAAyC;MACvCI,KAAK,GAAGD,MAAM,CAACH,CAAD,CAAd,CADuC,CAGvC;;MACA,IAAII,KAAK,CAACU,IAAN,KAAe,YAAnB,EAAiC;QAC/Bd,CAAC;;QACD,OAAOG,MAAM,CAACH,CAAD,CAAN,CAAUQ,KAAV,KAAoBJ,KAAK,CAACI,KAA1B,IAAmCL,MAAM,CAACH,CAAD,CAAN,CAAUc,IAAV,KAAmB,WAA7D,EAA0E;UACxEd,CAAC;QACF;;QACD;MACD,CAVsC,CAYvC;;;MACA,IAAII,KAAK,CAACU,IAAN,KAAe,SAAnB,EAA8B;QAC5B,IAAIvC,UAAU,CAAC6B,KAAK,CAACY,OAAP,CAAV,IAA6BP,aAAa,GAAG,CAAjD,EAAoD;UAClDA,aAAa;QACd;;QACD,IAAI/B,WAAW,CAAC0B,KAAK,CAACY,OAAP,CAAf,EAAgC;UAC9BP,aAAa;QACd;MACF;;MACD,IAAIA,aAAa,GAAG,CAApB,EAAuB;QAAE;MAAW;;MAEpC,IAAIL,KAAK,CAACU,IAAN,KAAe,MAAf,IAAyBxC,YAAY,CAACG,IAAb,CAAkB2B,KAAK,CAACY,OAAxB,CAA7B,EAA+D;QAE7D;QACA,IAAI,CAACL,SAAL,EAAgB;UACdA,SAAS,GAAGhC,eAAe,EAA3B;UACAC,KAAK,GAAG+B,SAAS,CAAC/B,KAAlB;UACAC,UAAU,GAAG8B,SAAS,CAAC9B,UAAvB;QACD;;QAEDU,IAAI,GAAGa,KAAK,CAACY,OAAb;QACApC,KAAK,CAACiC,MAAN,GAAe,CAAf;QACAhC,UAAU,CAACoC,IAAX,CAAgB1B,IAAhB;;QAEA,IAAI,CAACX,KAAK,CAACiC,MAAX,EAAmB;UAAE;QAAW,CAb6B,CAe7D;;;QACAR,KAAK,GAAG,EAAR;QACAG,KAAK,GAAGJ,KAAK,CAACI,KAAd;;QAEA,KAAKF,EAAE,GAAG,CAAV,EAAaA,EAAE,GAAG1B,KAAK,CAACiC,MAAxB,EAAgCP,EAAE,EAAlC,EAAsC;UAEpC,IAAI,CAACP,KAAK,CAACmB,MAAN,CAAaC,YAAb,CAA0BvC,KAAK,CAAC0B,EAAD,CAAL,CAAUvB,GAApC,CAAL,EAA+C;YAAE;UAAW;;UAE5DwB,GAAG,GAAGhB,IAAI,CAAC6B,OAAL,CAAaxC,KAAK,CAAC0B,EAAD,CAAL,CAAUf,IAAvB,CAAN;;UAEA,IAAIgB,GAAJ,EAAS;YACPC,KAAK,GAAGA,KAAR;YACAH,KAAK,CAACf,IAAN,CAAW;cACTwB,IAAI,EAAE,MADG;cAETE,OAAO,EAAEzB,IAAI,CAAC8B,KAAL,CAAW,CAAX,EAAcd,GAAd,CAFA;cAGTC,KAAK,EAAEA;YAHE,CAAX;UAKD;;UACDH,KAAK,CAACf,IAAN,CAAW;YACTwB,IAAI,EAAE,WADG;YAETQ,IAAI,EAAE1C,KAAK,CAAC0B,EAAD,CAAL,CAAUvB,GAFP;YAGTwC,KAAK,EAAE,EAHE;YAITf,KAAK,EAAEA,KAAK;UAJH,CAAX;UAMAH,KAAK,CAACf,IAAN,CAAW;YACTwB,IAAI,EAAE,MADG;YAETE,OAAO,EAAEpC,KAAK,CAAC0B,EAAD,CAAL,CAAUf,IAFV;YAGTiB,KAAK,EAAEA;UAHE,CAAX;UAKAH,KAAK,CAACf,IAAN,CAAW;YACTwB,IAAI,EAAE,YADG;YAETN,KAAK,EAAE,EAAEA;UAFA,CAAX;UAIAjB,IAAI,GAAGA,IAAI,CAAC8B,KAAL,CAAWd,GAAG,GAAG3B,KAAK,CAAC0B,EAAD,CAAL,CAAUf,IAAV,CAAesB,MAAhC,CAAP;QACD;;QACD,IAAItB,IAAI,CAACsB,MAAT,EAAiB;UACfR,KAAK,CAACf,IAAN,CAAW;YACTwB,IAAI,EAAE,MADG;YAETE,OAAO,EAAEzB,IAFA;YAGTiB,KAAK,EAAEA;UAHE,CAAX;QAKD,CAxD4D,CA0D7D;;;QACAE,WAAW,CAACT,CAAD,CAAX,CAAec,QAAf,GAA0BZ,MAAM,GAAG,GAAGqB,MAAH,CAAUrB,MAAM,CAACkB,KAAP,CAAa,CAAb,EAAgBrB,CAAhB,CAAV,EAA8BK,KAA9B,EAAqCF,MAAM,CAACkB,KAAP,CAAarB,CAAC,GAAG,CAAjB,CAArC,CAAnC;MACD;IACF;EACF;AACF,CArGD"},"metadata":{},"sourceType":"script"}