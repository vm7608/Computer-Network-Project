{"ast":null,"code":"'use strict';\n/**\n * Local dependencies\n */\n\nvar Ruler = require('./ruler');\n\nvar StateBlock = require('./rules_block/state_block');\n/**\n * Parser rules\n */\n\n\nvar _rules = [['code', require('./rules_block/code')], ['fences', require('./rules_block/fences'), ['paragraph', 'blockquote', 'list']], ['blockquote', require('./rules_block/blockquote'), ['paragraph', 'blockquote', 'list']], ['hr', require('./rules_block/hr'), ['paragraph', 'blockquote', 'list']], ['list', require('./rules_block/list'), ['paragraph', 'blockquote']], ['footnote', require('./rules_block/footnote'), ['paragraph']], ['heading', require('./rules_block/heading'), ['paragraph', 'blockquote']], ['lheading', require('./rules_block/lheading')], ['htmlblock', require('./rules_block/htmlblock'), ['paragraph', 'blockquote']], ['table', require('./rules_block/table'), ['paragraph']], ['deflist', require('./rules_block/deflist'), ['paragraph']], ['paragraph', require('./rules_block/paragraph')]];\n/**\n * Block Parser class\n *\n * @api private\n */\n\nfunction ParserBlock() {\n  this.ruler = new Ruler();\n\n  for (var i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1], {\n      alt: (_rules[i][2] || []).slice()\n    });\n  }\n}\n/**\n * Generate tokens for the given input range.\n *\n * @param  {Object} `state` Has properties like `src`, `parser`, `options` etc\n * @param  {Number} `startLine`\n * @param  {Number} `endLine`\n * @api private\n */\n\n\nParserBlock.prototype.tokenize = function (state, startLine, endLine) {\n  var rules = this.ruler.getRules('');\n  var len = rules.length;\n  var line = startLine;\n  var hasEmptyLines = false;\n  var ok, i;\n\n  while (line < endLine) {\n    state.line = line = state.skipEmptyLines(line);\n\n    if (line >= endLine) {\n      break;\n    } // Termination condition for nested calls.\n    // Nested calls currently used for blockquotes & lists\n\n\n    if (state.tShift[line] < state.blkIndent) {\n      break;\n    } // Try all possible rules.\n    // On success, rule should:\n    //\n    // - update `state.line`\n    // - update `state.tokens`\n    // - return true\n\n\n    for (i = 0; i < len; i++) {\n      ok = rules[i](state, line, endLine, false);\n\n      if (ok) {\n        break;\n      }\n    } // set state.tight iff we had an empty line before current tag\n    // i.e. latest empty line should not count\n\n\n    state.tight = !hasEmptyLines; // paragraph might \"eat\" one newline after it in nested lists\n\n    if (state.isEmpty(state.line - 1)) {\n      hasEmptyLines = true;\n    }\n\n    line = state.line;\n\n    if (line < endLine && state.isEmpty(line)) {\n      hasEmptyLines = true;\n      line++; // two empty lines should stop the parser in list mode\n\n      if (line < endLine && state.parentType === 'list' && state.isEmpty(line)) {\n        break;\n      }\n\n      state.line = line;\n    }\n  }\n};\n\nvar TABS_SCAN_RE = /[\\n\\t]/g;\nvar NEWLINES_RE = /\\r[\\n\\u0085]|[\\u2424\\u2028\\u0085]/g;\nvar SPACES_RE = /\\u00a0/g;\n/**\n * Tokenize the given `str`.\n *\n * @param  {String} `str` Source string\n * @param  {Object} `options`\n * @param  {Object} `env`\n * @param  {Array} `outTokens`\n * @api private\n */\n\nParserBlock.prototype.parse = function (str, options, env, outTokens) {\n  var state,\n      lineStart = 0,\n      lastTabPos = 0;\n\n  if (!str) {\n    return [];\n  } // Normalize spaces\n\n\n  str = str.replace(SPACES_RE, ' '); // Normalize newlines\n\n  str = str.replace(NEWLINES_RE, '\\n'); // Replace tabs with proper number of spaces (1..4)\n\n  if (str.indexOf('\\t') >= 0) {\n    str = str.replace(TABS_SCAN_RE, function (match, offset) {\n      var result;\n\n      if (str.charCodeAt(offset) === 0x0A) {\n        lineStart = offset + 1;\n        lastTabPos = 0;\n        return match;\n      }\n\n      result = '    '.slice((offset - lineStart - lastTabPos) % 4);\n      lastTabPos = offset - lineStart + 1;\n      return result;\n    });\n  }\n\n  state = new StateBlock(str, this, options, env, outTokens);\n  this.tokenize(state, state.line, state.lineMax);\n};\n/**\n * Expose `ParserBlock`\n */\n\n\nmodule.exports = ParserBlock;","map":{"version":3,"names":["Ruler","require","StateBlock","_rules","ParserBlock","ruler","i","length","push","alt","slice","prototype","tokenize","state","startLine","endLine","rules","getRules","len","line","hasEmptyLines","ok","skipEmptyLines","tShift","blkIndent","tight","isEmpty","parentType","TABS_SCAN_RE","NEWLINES_RE","SPACES_RE","parse","str","options","env","outTokens","lineStart","lastTabPos","replace","indexOf","match","offset","result","charCodeAt","lineMax","module","exports"],"sources":["C:/Users/caoma/Downloads/online-shop/node_modules/remarkable/lib/parser_block.js"],"sourcesContent":["'use strict';\n\n/**\n * Local dependencies\n */\n\nvar Ruler      = require('./ruler');\nvar StateBlock = require('./rules_block/state_block');\n\n/**\n * Parser rules\n */\n\nvar _rules = [\n  [ 'code',       require('./rules_block/code') ],\n  [ 'fences',     require('./rules_block/fences'),     [ 'paragraph', 'blockquote', 'list' ] ],\n  [ 'blockquote', require('./rules_block/blockquote'), [ 'paragraph', 'blockquote', 'list' ] ],\n  [ 'hr',         require('./rules_block/hr'),         [ 'paragraph', 'blockquote', 'list' ] ],\n  [ 'list',       require('./rules_block/list'),       [ 'paragraph', 'blockquote' ] ],\n  [ 'footnote',   require('./rules_block/footnote'),   [ 'paragraph' ] ],\n  [ 'heading',    require('./rules_block/heading'),    [ 'paragraph', 'blockquote' ] ],\n  [ 'lheading',   require('./rules_block/lheading') ],\n  [ 'htmlblock',  require('./rules_block/htmlblock'),  [ 'paragraph', 'blockquote' ] ],\n  [ 'table',      require('./rules_block/table'),      [ 'paragraph' ] ],\n  [ 'deflist',    require('./rules_block/deflist'),    [ 'paragraph' ] ],\n  [ 'paragraph',  require('./rules_block/paragraph') ]\n];\n\n/**\n * Block Parser class\n *\n * @api private\n */\n\nfunction ParserBlock() {\n  this.ruler = new Ruler();\n  for (var i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1], {\n      alt: (_rules[i][2] || []).slice()\n    });\n  }\n}\n\n/**\n * Generate tokens for the given input range.\n *\n * @param  {Object} `state` Has properties like `src`, `parser`, `options` etc\n * @param  {Number} `startLine`\n * @param  {Number} `endLine`\n * @api private\n */\n\nParserBlock.prototype.tokenize = function (state, startLine, endLine) {\n  var rules = this.ruler.getRules('');\n  var len = rules.length;\n  var line = startLine;\n  var hasEmptyLines = false;\n  var ok, i;\n\n  while (line < endLine) {\n    state.line = line = state.skipEmptyLines(line);\n    if (line >= endLine) {\n      break;\n    }\n\n    // Termination condition for nested calls.\n    // Nested calls currently used for blockquotes & lists\n    if (state.tShift[line] < state.blkIndent) {\n      break;\n    }\n\n    // Try all possible rules.\n    // On success, rule should:\n    //\n    // - update `state.line`\n    // - update `state.tokens`\n    // - return true\n\n    for (i = 0; i < len; i++) {\n      ok = rules[i](state, line, endLine, false);\n      if (ok) {\n        break;\n      }\n    }\n\n    // set state.tight iff we had an empty line before current tag\n    // i.e. latest empty line should not count\n    state.tight = !hasEmptyLines;\n\n    // paragraph might \"eat\" one newline after it in nested lists\n    if (state.isEmpty(state.line - 1)) {\n      hasEmptyLines = true;\n    }\n\n    line = state.line;\n\n    if (line < endLine && state.isEmpty(line)) {\n      hasEmptyLines = true;\n      line++;\n\n      // two empty lines should stop the parser in list mode\n      if (line < endLine && state.parentType === 'list' && state.isEmpty(line)) { break; }\n      state.line = line;\n    }\n  }\n};\n\nvar TABS_SCAN_RE = /[\\n\\t]/g;\nvar NEWLINES_RE  = /\\r[\\n\\u0085]|[\\u2424\\u2028\\u0085]/g;\nvar SPACES_RE    = /\\u00a0/g;\n\n/**\n * Tokenize the given `str`.\n *\n * @param  {String} `str` Source string\n * @param  {Object} `options`\n * @param  {Object} `env`\n * @param  {Array} `outTokens`\n * @api private\n */\n\nParserBlock.prototype.parse = function (str, options, env, outTokens) {\n  var state, lineStart = 0, lastTabPos = 0;\n  if (!str) { return []; }\n\n  // Normalize spaces\n  str = str.replace(SPACES_RE, ' ');\n\n  // Normalize newlines\n  str = str.replace(NEWLINES_RE, '\\n');\n\n  // Replace tabs with proper number of spaces (1..4)\n  if (str.indexOf('\\t') >= 0) {\n    str = str.replace(TABS_SCAN_RE, function (match, offset) {\n      var result;\n      if (str.charCodeAt(offset) === 0x0A) {\n        lineStart = offset + 1;\n        lastTabPos = 0;\n        return match;\n      }\n      result = '    '.slice((offset - lineStart - lastTabPos) % 4);\n      lastTabPos = offset - lineStart + 1;\n      return result;\n    });\n  }\n\n  state = new StateBlock(str, this, options, env, outTokens);\n  this.tokenize(state, state.line, state.lineMax);\n};\n\n/**\n * Expose `ParserBlock`\n */\n\nmodule.exports = ParserBlock;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}