{"ast":null,"code":"// Inline parser state\n'use strict';\n\nfunction StateInline(src, parserInline, options, env, outTokens) {\n  this.src = src;\n  this.env = env;\n  this.options = options;\n  this.parser = parserInline;\n  this.tokens = outTokens;\n  this.pos = 0;\n  this.posMax = this.src.length;\n  this.level = 0;\n  this.pending = '';\n  this.pendingLevel = 0;\n  this.cache = []; // Stores { start: end } pairs. Useful for backtrack\n  // optimization of pairs parse (emphasis, strikes).\n  // Link parser state vars\n\n  this.isInLabel = false; // Set true when seek link label - we should disable\n  // \"paired\" rules (emphasis, strikes) to not skip\n  // tailing `]`\n\n  this.linkLevel = 0; // Increment for each nesting link. Used to prevent\n  // nesting in definitions\n\n  this.linkContent = ''; // Temporary storage for link url\n\n  this.labelUnmatchedScopes = 0; // Track unpaired `[` for link labels\n  // (backtrack optimization)\n} // Flush pending text\n//\n\n\nStateInline.prototype.pushPending = function () {\n  this.tokens.push({\n    type: 'text',\n    content: this.pending,\n    level: this.pendingLevel\n  });\n  this.pending = '';\n}; // Push new token to \"stream\".\n// If pending text exists - flush it as text token\n//\n\n\nStateInline.prototype.push = function (token) {\n  if (this.pending) {\n    this.pushPending();\n  }\n\n  this.tokens.push(token);\n  this.pendingLevel = this.level;\n}; // Store value to cache.\n// !!! Implementation has parser-specific optimizations\n// !!! keys MUST be integer, >= 0; values MUST be integer, > 0\n//\n\n\nStateInline.prototype.cacheSet = function (key, val) {\n  for (var i = this.cache.length; i <= key; i++) {\n    this.cache.push(0);\n  }\n\n  this.cache[key] = val;\n}; // Get cache value\n//\n\n\nStateInline.prototype.cacheGet = function (key) {\n  return key < this.cache.length ? this.cache[key] : 0;\n};\n\nmodule.exports = StateInline;","map":{"version":3,"names":["StateInline","src","parserInline","options","env","outTokens","parser","tokens","pos","posMax","length","level","pending","pendingLevel","cache","isInLabel","linkLevel","linkContent","labelUnmatchedScopes","prototype","pushPending","push","type","content","token","cacheSet","key","val","i","cacheGet","module","exports"],"sources":["C:/Users/caoma/Downloads/online-shop/node_modules/remarkable/lib/rules_inline/state_inline.js"],"sourcesContent":["// Inline parser state\n\n'use strict';\n\nfunction StateInline(src, parserInline, options, env, outTokens) {\n  this.src = src;\n  this.env = env;\n  this.options = options;\n  this.parser = parserInline;\n  this.tokens = outTokens;\n  this.pos = 0;\n  this.posMax = this.src.length;\n  this.level = 0;\n  this.pending = '';\n  this.pendingLevel = 0;\n\n  this.cache = [];        // Stores { start: end } pairs. Useful for backtrack\n                          // optimization of pairs parse (emphasis, strikes).\n\n  // Link parser state vars\n\n  this.isInLabel = false; // Set true when seek link label - we should disable\n                          // \"paired\" rules (emphasis, strikes) to not skip\n                          // tailing `]`\n\n  this.linkLevel = 0;     // Increment for each nesting link. Used to prevent\n                          // nesting in definitions\n\n  this.linkContent = '';  // Temporary storage for link url\n\n  this.labelUnmatchedScopes = 0; // Track unpaired `[` for link labels\n                                 // (backtrack optimization)\n}\n\n// Flush pending text\n//\nStateInline.prototype.pushPending = function () {\n  this.tokens.push({\n    type: 'text',\n    content: this.pending,\n    level: this.pendingLevel\n  });\n  this.pending = '';\n};\n\n// Push new token to \"stream\".\n// If pending text exists - flush it as text token\n//\nStateInline.prototype.push = function (token) {\n  if (this.pending) {\n    this.pushPending();\n  }\n\n  this.tokens.push(token);\n  this.pendingLevel = this.level;\n};\n\n// Store value to cache.\n// !!! Implementation has parser-specific optimizations\n// !!! keys MUST be integer, >= 0; values MUST be integer, > 0\n//\nStateInline.prototype.cacheSet = function (key, val) {\n  for (var i = this.cache.length; i <= key; i++) {\n    this.cache.push(0);\n  }\n\n  this.cache[key] = val;\n};\n\n// Get cache value\n//\nStateInline.prototype.cacheGet = function (key) {\n  return key < this.cache.length ? this.cache[key] : 0;\n};\n\nmodule.exports = StateInline;\n"],"mappings":"AAAA;AAEA;;AAEA,SAASA,WAAT,CAAqBC,GAArB,EAA0BC,YAA1B,EAAwCC,OAAxC,EAAiDC,GAAjD,EAAsDC,SAAtD,EAAiE;EAC/D,KAAKJ,GAAL,GAAWA,GAAX;EACA,KAAKG,GAAL,GAAWA,GAAX;EACA,KAAKD,OAAL,GAAeA,OAAf;EACA,KAAKG,MAAL,GAAcJ,YAAd;EACA,KAAKK,MAAL,GAAcF,SAAd;EACA,KAAKG,GAAL,GAAW,CAAX;EACA,KAAKC,MAAL,GAAc,KAAKR,GAAL,CAASS,MAAvB;EACA,KAAKC,KAAL,GAAa,CAAb;EACA,KAAKC,OAAL,GAAe,EAAf;EACA,KAAKC,YAAL,GAAoB,CAApB;EAEA,KAAKC,KAAL,GAAa,EAAb,CAZ+D,CAYvC;EACA;EAExB;;EAEA,KAAKC,SAAL,GAAiB,KAAjB,CAjB+D,CAiBvC;EACA;EACA;;EAExB,KAAKC,SAAL,GAAiB,CAAjB,CArB+D,CAqBvC;EACA;;EAExB,KAAKC,WAAL,GAAmB,EAAnB,CAxB+D,CAwBvC;;EAExB,KAAKC,oBAAL,GAA4B,CAA5B,CA1B+D,CA0BhC;EACA;AAChC,C,CAED;AACA;;;AACAlB,WAAW,CAACmB,SAAZ,CAAsBC,WAAtB,GAAoC,YAAY;EAC9C,KAAKb,MAAL,CAAYc,IAAZ,CAAiB;IACfC,IAAI,EAAE,MADS;IAEfC,OAAO,EAAE,KAAKX,OAFC;IAGfD,KAAK,EAAE,KAAKE;EAHG,CAAjB;EAKA,KAAKD,OAAL,GAAe,EAAf;AACD,CAPD,C,CASA;AACA;AACA;;;AACAZ,WAAW,CAACmB,SAAZ,CAAsBE,IAAtB,GAA6B,UAAUG,KAAV,EAAiB;EAC5C,IAAI,KAAKZ,OAAT,EAAkB;IAChB,KAAKQ,WAAL;EACD;;EAED,KAAKb,MAAL,CAAYc,IAAZ,CAAiBG,KAAjB;EACA,KAAKX,YAAL,GAAoB,KAAKF,KAAzB;AACD,CAPD,C,CASA;AACA;AACA;AACA;;;AACAX,WAAW,CAACmB,SAAZ,CAAsBM,QAAtB,GAAiC,UAAUC,GAAV,EAAeC,GAAf,EAAoB;EACnD,KAAK,IAAIC,CAAC,GAAG,KAAKd,KAAL,CAAWJ,MAAxB,EAAgCkB,CAAC,IAAIF,GAArC,EAA0CE,CAAC,EAA3C,EAA+C;IAC7C,KAAKd,KAAL,CAAWO,IAAX,CAAgB,CAAhB;EACD;;EAED,KAAKP,KAAL,CAAWY,GAAX,IAAkBC,GAAlB;AACD,CAND,C,CAQA;AACA;;;AACA3B,WAAW,CAACmB,SAAZ,CAAsBU,QAAtB,GAAiC,UAAUH,GAAV,EAAe;EAC9C,OAAOA,GAAG,GAAG,KAAKZ,KAAL,CAAWJ,MAAjB,GAA0B,KAAKI,KAAL,CAAWY,GAAX,CAA1B,GAA4C,CAAnD;AACD,CAFD;;AAIAI,MAAM,CAACC,OAAP,GAAiB/B,WAAjB"},"metadata":{},"sourceType":"script"}