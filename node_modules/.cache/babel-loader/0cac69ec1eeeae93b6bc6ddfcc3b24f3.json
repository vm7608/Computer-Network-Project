{"ast":null,"code":"// Parser state class\n'use strict';\n\nfunction StateBlock(src, parser, options, env, tokens) {\n  var ch, s, start, pos, len, indent, indent_found;\n  this.src = src; // Shortcuts to simplify nested calls\n\n  this.parser = parser;\n  this.options = options;\n  this.env = env; //\n  // Internal state vartiables\n  //\n\n  this.tokens = tokens;\n  this.bMarks = []; // line begin offsets for fast jumps\n\n  this.eMarks = []; // line end offsets for fast jumps\n\n  this.tShift = []; // indent for each line\n  // block parser variables\n\n  this.blkIndent = 0; // required block content indent\n  // (for example, if we are in list)\n\n  this.line = 0; // line index in src\n\n  this.lineMax = 0; // lines count\n\n  this.tight = false; // loose/tight mode for lists\n\n  this.parentType = 'root'; // if `list`, block parser stops on two newlines\n\n  this.ddIndent = -1; // indent of the current dd block (-1 if there isn't any)\n\n  this.level = 0; // renderer\n\n  this.result = ''; // Create caches\n  // Generate markers.\n\n  s = this.src;\n  indent = 0;\n  indent_found = false;\n\n  for (start = pos = indent = 0, len = s.length; pos < len; pos++) {\n    ch = s.charCodeAt(pos);\n\n    if (!indent_found) {\n      if (ch === 0x20\n      /* space */\n      ) {\n        indent++;\n        continue;\n      } else {\n        indent_found = true;\n      }\n    }\n\n    if (ch === 0x0A || pos === len - 1) {\n      if (ch !== 0x0A) {\n        pos++;\n      }\n\n      this.bMarks.push(start);\n      this.eMarks.push(pos);\n      this.tShift.push(indent);\n      indent_found = false;\n      indent = 0;\n      start = pos + 1;\n    }\n  } // Push fake entry to simplify cache bounds checks\n\n\n  this.bMarks.push(s.length);\n  this.eMarks.push(s.length);\n  this.tShift.push(0);\n  this.lineMax = this.bMarks.length - 1; // don't count last fake line\n}\n\nStateBlock.prototype.isEmpty = function isEmpty(line) {\n  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];\n};\n\nStateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {\n  for (var max = this.lineMax; from < max; from++) {\n    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {\n      break;\n    }\n  }\n\n  return from;\n}; // Skip spaces from given position.\n\n\nStateBlock.prototype.skipSpaces = function skipSpaces(pos) {\n  for (var max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== 0x20\n    /* space */\n    ) {\n      break;\n    }\n  }\n\n  return pos;\n}; // Skip char codes from given position\n\n\nStateBlock.prototype.skipChars = function skipChars(pos, code) {\n  for (var max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== code) {\n      break;\n    }\n  }\n\n  return pos;\n}; // Skip char codes reverse from given position - 1\n\n\nStateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {\n  if (pos <= min) {\n    return pos;\n  }\n\n  while (pos > min) {\n    if (code !== this.src.charCodeAt(--pos)) {\n      return pos + 1;\n    }\n  }\n\n  return pos;\n}; // cut lines range from source.\n\n\nStateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {\n  var i,\n      first,\n      last,\n      queue,\n      shift,\n      line = begin;\n\n  if (begin >= end) {\n    return '';\n  } // Opt: don't use push queue for single line;\n\n\n  if (line + 1 === end) {\n    first = this.bMarks[line] + Math.min(this.tShift[line], indent);\n    last = keepLastLF ? this.eMarks[line] + 1 : this.eMarks[line];\n    return this.src.slice(first, last);\n  }\n\n  queue = new Array(end - begin);\n\n  for (i = 0; line < end; line++, i++) {\n    shift = this.tShift[line];\n\n    if (shift > indent) {\n      shift = indent;\n    }\n\n    if (shift < 0) {\n      shift = 0;\n    }\n\n    first = this.bMarks[line] + shift;\n\n    if (line + 1 < end || keepLastLF) {\n      // No need for bounds check because we have fake entry on tail.\n      last = this.eMarks[line] + 1;\n    } else {\n      last = this.eMarks[line];\n    }\n\n    queue[i] = this.src.slice(first, last);\n  }\n\n  return queue.join('');\n};\n\nmodule.exports = StateBlock;","map":{"version":3,"names":["StateBlock","src","parser","options","env","tokens","ch","s","start","pos","len","indent","indent_found","bMarks","eMarks","tShift","blkIndent","line","lineMax","tight","parentType","ddIndent","level","result","length","charCodeAt","push","prototype","isEmpty","skipEmptyLines","from","max","skipSpaces","skipChars","code","skipCharsBack","min","getLines","begin","end","keepLastLF","i","first","last","queue","shift","Math","slice","Array","join","module","exports"],"sources":["C:/Users/caoma/Downloads/another/online-shop/node_modules/remarkable/lib/rules_block/state_block.js"],"sourcesContent":["// Parser state class\n\n'use strict';\n\n\nfunction StateBlock(src, parser, options, env, tokens) {\n  var ch, s, start, pos, len, indent, indent_found;\n\n  this.src = src;\n\n  // Shortcuts to simplify nested calls\n  this.parser = parser;\n\n  this.options = options;\n\n  this.env = env;\n\n  //\n  // Internal state vartiables\n  //\n\n  this.tokens = tokens;\n\n  this.bMarks = [];  // line begin offsets for fast jumps\n  this.eMarks = [];  // line end offsets for fast jumps\n  this.tShift = [];  // indent for each line\n\n  // block parser variables\n  this.blkIndent  = 0; // required block content indent\n                       // (for example, if we are in list)\n  this.line       = 0; // line index in src\n  this.lineMax    = 0; // lines count\n  this.tight      = false;  // loose/tight mode for lists\n  this.parentType = 'root'; // if `list`, block parser stops on two newlines\n  this.ddIndent   = -1; // indent of the current dd block (-1 if there isn't any)\n\n  this.level = 0;\n\n  // renderer\n  this.result = '';\n\n  // Create caches\n  // Generate markers.\n  s = this.src;\n  indent = 0;\n  indent_found = false;\n\n  for (start = pos = indent = 0, len = s.length; pos < len; pos++) {\n    ch = s.charCodeAt(pos);\n\n    if (!indent_found) {\n      if (ch === 0x20/* space */) {\n        indent++;\n        continue;\n      } else {\n        indent_found = true;\n      }\n    }\n\n    if (ch === 0x0A || pos === len - 1) {\n      if (ch !== 0x0A) { pos++; }\n      this.bMarks.push(start);\n      this.eMarks.push(pos);\n      this.tShift.push(indent);\n\n      indent_found = false;\n      indent = 0;\n      start = pos + 1;\n    }\n  }\n\n  // Push fake entry to simplify cache bounds checks\n  this.bMarks.push(s.length);\n  this.eMarks.push(s.length);\n  this.tShift.push(0);\n\n  this.lineMax = this.bMarks.length - 1; // don't count last fake line\n}\n\nStateBlock.prototype.isEmpty = function isEmpty(line) {\n  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];\n};\n\nStateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {\n  for (var max = this.lineMax; from < max; from++) {\n    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {\n      break;\n    }\n  }\n  return from;\n};\n\n// Skip spaces from given position.\nStateBlock.prototype.skipSpaces = function skipSpaces(pos) {\n  for (var max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== 0x20/* space */) { break; }\n  }\n  return pos;\n};\n\n// Skip char codes from given position\nStateBlock.prototype.skipChars = function skipChars(pos, code) {\n  for (var max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== code) { break; }\n  }\n  return pos;\n};\n\n// Skip char codes reverse from given position - 1\nStateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {\n  if (pos <= min) { return pos; }\n\n  while (pos > min) {\n    if (code !== this.src.charCodeAt(--pos)) { return pos + 1; }\n  }\n  return pos;\n};\n\n// cut lines range from source.\nStateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {\n  var i, first, last, queue, shift,\n      line = begin;\n\n  if (begin >= end) {\n    return '';\n  }\n\n  // Opt: don't use push queue for single line;\n  if (line + 1 === end) {\n    first = this.bMarks[line] + Math.min(this.tShift[line], indent);\n    last = keepLastLF ? this.eMarks[line] + 1 : this.eMarks[line];\n    return this.src.slice(first, last);\n  }\n\n  queue = new Array(end - begin);\n\n  for (i = 0; line < end; line++, i++) {\n    shift = this.tShift[line];\n    if (shift > indent) { shift = indent; }\n    if (shift < 0) { shift = 0; }\n\n    first = this.bMarks[line] + shift;\n\n    if (line + 1 < end || keepLastLF) {\n      // No need for bounds check because we have fake entry on tail.\n      last = this.eMarks[line] + 1;\n    } else {\n      last = this.eMarks[line];\n    }\n\n    queue[i] = this.src.slice(first, last);\n  }\n\n  return queue.join('');\n};\n\n\nmodule.exports = StateBlock;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}