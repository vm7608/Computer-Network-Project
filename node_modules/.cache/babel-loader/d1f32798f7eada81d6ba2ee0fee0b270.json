{"ast":null,"code":"// Process [links](<to> \"stuff\")\n'use strict';\n\nvar parseLinkLabel = require('../helpers/parse_link_label');\n\nvar parseLinkDestination = require('../helpers/parse_link_destination');\n\nvar parseLinkTitle = require('../helpers/parse_link_title');\n\nvar normalizeReference = require('../helpers/normalize_reference');\n\nmodule.exports = function links(state, silent) {\n  var labelStart,\n      labelEnd,\n      label,\n      href,\n      title,\n      pos,\n      ref,\n      code,\n      isImage = false,\n      oldPos = state.pos,\n      max = state.posMax,\n      start = state.pos,\n      marker = state.src.charCodeAt(start);\n\n  if (marker === 0x21\n  /* ! */\n  ) {\n    isImage = true;\n    marker = state.src.charCodeAt(++start);\n  }\n\n  if (marker !== 0x5B\n  /* [ */\n  ) {\n    return false;\n  }\n\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  }\n\n  labelStart = start + 1;\n  labelEnd = parseLinkLabel(state, start); // parser failed to find ']', so it's not a valid link\n\n  if (labelEnd < 0) {\n    return false;\n  }\n\n  pos = labelEnd + 1;\n\n  if (pos < max && state.src.charCodeAt(pos) === 0x28\n  /* ( */\n  ) {\n    //\n    // Inline link\n    //\n    // [link](  <href>  \"title\"  )\n    //        ^^ skipping these spaces\n    pos++;\n\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n\n      if (code !== 0x20 && code !== 0x0A) {\n        break;\n      }\n    }\n\n    if (pos >= max) {\n      return false;\n    } // [link](  <href>  \"title\"  )\n    //          ^^^^^^ parsing link destination\n\n\n    start = pos;\n\n    if (parseLinkDestination(state, pos)) {\n      href = state.linkContent;\n      pos = state.pos;\n    } else {\n      href = '';\n    } // [link](  <href>  \"title\"  )\n    //                ^^ skipping these spaces\n\n\n    start = pos;\n\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n\n      if (code !== 0x20 && code !== 0x0A) {\n        break;\n      }\n    } // [link](  <href>  \"title\"  )\n    //                  ^^^^^^^ parsing link title\n\n\n    if (pos < max && start !== pos && parseLinkTitle(state, pos)) {\n      title = state.linkContent;\n      pos = state.pos; // [link](  <href>  \"title\"  )\n      //                         ^^ skipping these spaces\n\n      for (; pos < max; pos++) {\n        code = state.src.charCodeAt(pos);\n\n        if (code !== 0x20 && code !== 0x0A) {\n          break;\n        }\n      }\n    } else {\n      title = '';\n    }\n\n    if (pos >= max || state.src.charCodeAt(pos) !== 0x29\n    /* ) */\n    ) {\n      state.pos = oldPos;\n      return false;\n    }\n\n    pos++;\n  } else {\n    //\n    // Link reference\n    //\n    // do not allow nested reference links\n    if (state.linkLevel > 0) {\n      return false;\n    } // [foo]  [bar]\n    //      ^^ optional whitespace (can include newlines)\n\n\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n\n      if (code !== 0x20 && code !== 0x0A) {\n        break;\n      }\n    }\n\n    if (pos < max && state.src.charCodeAt(pos) === 0x5B\n    /* [ */\n    ) {\n      start = pos + 1;\n      pos = parseLinkLabel(state, pos);\n\n      if (pos >= 0) {\n        label = state.src.slice(start, pos++);\n      } else {\n        pos = start - 1;\n      }\n    } // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n\n\n    if (!label) {\n      if (typeof label === 'undefined') {\n        pos = labelEnd + 1;\n      }\n\n      label = state.src.slice(labelStart, labelEnd);\n    }\n\n    ref = state.env.references[normalizeReference(label)];\n\n    if (!ref) {\n      state.pos = oldPos;\n      return false;\n    }\n\n    href = ref.href;\n    title = ref.title;\n  } //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n\n\n  if (!silent) {\n    state.pos = labelStart;\n    state.posMax = labelEnd;\n\n    if (isImage) {\n      state.push({\n        type: 'image',\n        src: href,\n        title: title,\n        alt: state.src.substr(labelStart, labelEnd - labelStart),\n        level: state.level\n      });\n    } else {\n      state.push({\n        type: 'link_open',\n        href: href,\n        title: title,\n        level: state.level++\n      });\n      state.linkLevel++;\n      state.parser.tokenize(state);\n      state.linkLevel--;\n      state.push({\n        type: 'link_close',\n        level: --state.level\n      });\n    }\n  }\n\n  state.pos = pos;\n  state.posMax = max;\n  return true;\n};","map":{"version":3,"names":["parseLinkLabel","require","parseLinkDestination","parseLinkTitle","normalizeReference","module","exports","links","state","silent","labelStart","labelEnd","label","href","title","pos","ref","code","isImage","oldPos","max","posMax","start","marker","src","charCodeAt","level","options","maxNesting","linkContent","linkLevel","slice","env","references","push","type","alt","substr","parser","tokenize"],"sources":["C:/Users/caoma/Downloads/another/online-shop/node_modules/remarkable/lib/rules_inline/links.js"],"sourcesContent":["// Process [links](<to> \"stuff\")\n\n'use strict';\n\nvar parseLinkLabel       = require('../helpers/parse_link_label');\nvar parseLinkDestination = require('../helpers/parse_link_destination');\nvar parseLinkTitle       = require('../helpers/parse_link_title');\nvar normalizeReference   = require('../helpers/normalize_reference');\n\n\nmodule.exports = function links(state, silent) {\n  var labelStart,\n      labelEnd,\n      label,\n      href,\n      title,\n      pos,\n      ref,\n      code,\n      isImage = false,\n      oldPos = state.pos,\n      max = state.posMax,\n      start = state.pos,\n      marker = state.src.charCodeAt(start);\n\n  if (marker === 0x21/* ! */) {\n    isImage = true;\n    marker = state.src.charCodeAt(++start);\n  }\n\n  if (marker !== 0x5B/* [ */) { return false; }\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  labelStart = start + 1;\n  labelEnd = parseLinkLabel(state, start);\n\n  // parser failed to find ']', so it's not a valid link\n  if (labelEnd < 0) { return false; }\n\n  pos = labelEnd + 1;\n  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {\n    //\n    // Inline link\n    //\n\n    // [link](  <href>  \"title\"  )\n    //        ^^ skipping these spaces\n    pos++;\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (code !== 0x20 && code !== 0x0A) { break; }\n    }\n    if (pos >= max) { return false; }\n\n    // [link](  <href>  \"title\"  )\n    //          ^^^^^^ parsing link destination\n    start = pos;\n    if (parseLinkDestination(state, pos)) {\n      href = state.linkContent;\n      pos = state.pos;\n    } else {\n      href = '';\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                ^^ skipping these spaces\n    start = pos;\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (code !== 0x20 && code !== 0x0A) { break; }\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                  ^^^^^^^ parsing link title\n    if (pos < max && start !== pos && parseLinkTitle(state, pos)) {\n      title = state.linkContent;\n      pos = state.pos;\n\n      // [link](  <href>  \"title\"  )\n      //                         ^^ skipping these spaces\n      for (; pos < max; pos++) {\n        code = state.src.charCodeAt(pos);\n        if (code !== 0x20 && code !== 0x0A) { break; }\n      }\n    } else {\n      title = '';\n    }\n\n    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {\n      state.pos = oldPos;\n      return false;\n    }\n    pos++;\n  } else {\n    //\n    // Link reference\n    //\n\n    // do not allow nested reference links\n    if (state.linkLevel > 0) { return false; }\n\n    // [foo]  [bar]\n    //      ^^ optional whitespace (can include newlines)\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (code !== 0x20 && code !== 0x0A) { break; }\n    }\n\n    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {\n      start = pos + 1;\n      pos = parseLinkLabel(state, pos);\n      if (pos >= 0) {\n        label = state.src.slice(start, pos++);\n      } else {\n        pos = start - 1;\n      }\n    }\n\n    // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n    if (!label) {\n      if (typeof label === 'undefined') {\n        pos = labelEnd + 1;\n      }\n      label = state.src.slice(labelStart, labelEnd);\n    }\n\n    ref = state.env.references[normalizeReference(label)];\n    if (!ref) {\n      state.pos = oldPos;\n      return false;\n    }\n    href = ref.href;\n    title = ref.title;\n  }\n\n  //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    state.pos = labelStart;\n    state.posMax = labelEnd;\n\n    if (isImage) {\n      state.push({\n        type: 'image',\n        src: href,\n        title: title,\n        alt: state.src.substr(labelStart, labelEnd - labelStart),\n        level: state.level\n      });\n    } else {\n      state.push({\n        type: 'link_open',\n        href: href,\n        title: title,\n        level: state.level++\n      });\n      state.linkLevel++;\n      state.parser.tokenize(state);\n      state.linkLevel--;\n      state.push({ type: 'link_close', level: --state.level });\n    }\n  }\n\n  state.pos = pos;\n  state.posMax = max;\n  return true;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}