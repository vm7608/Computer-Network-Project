{"ast":null,"code":"// Definition lists\n'use strict'; // Search `[:~][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\n\nfunction skipMarker(state, line) {\n  var pos,\n      marker,\n      start = state.bMarks[line] + state.tShift[line],\n      max = state.eMarks[line];\n\n  if (start >= max) {\n    return -1;\n  } // Check bullet\n\n\n  marker = state.src.charCodeAt(start++);\n\n  if (marker !== 0x7E\n  /* ~ */\n  && marker !== 0x3A\n  /* : */\n  ) {\n    return -1;\n  }\n\n  pos = state.skipSpaces(start); // require space after \":\"\n\n  if (start === pos) {\n    return -1;\n  } // no empty definitions, e.g. \"  : \"\n\n\n  if (pos >= max) {\n    return -1;\n  }\n\n  return pos;\n}\n\nfunction markTightParagraphs(state, idx) {\n  var i,\n      l,\n      level = state.level + 2;\n\n  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n      state.tokens[i + 2].tight = true;\n      state.tokens[i].tight = true;\n      i += 2;\n    }\n  }\n}\n\nmodule.exports = function deflist(state, startLine, endLine, silent) {\n  var contentStart, ddLine, dtLine, itemLines, listLines, listTokIdx, nextLine, oldIndent, oldDDIndent, oldParentType, oldTShift, oldTight, prevEmptyEnd, tight;\n\n  if (silent) {\n    // quirk: validation mode validates a dd block only, not a whole deflist\n    if (state.ddIndent < 0) {\n      return false;\n    }\n\n    return skipMarker(state, startLine) >= 0;\n  }\n\n  nextLine = startLine + 1;\n\n  if (state.isEmpty(nextLine)) {\n    if (++nextLine > endLine) {\n      return false;\n    }\n  }\n\n  if (state.tShift[nextLine] < state.blkIndent) {\n    return false;\n  }\n\n  contentStart = skipMarker(state, nextLine);\n\n  if (contentStart < 0) {\n    return false;\n  }\n\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  } // Start list\n\n\n  listTokIdx = state.tokens.length;\n  state.tokens.push({\n    type: 'dl_open',\n    lines: listLines = [startLine, 0],\n    level: state.level++\n  }); //\n  // Iterate list items\n  //\n\n  dtLine = startLine;\n  ddLine = nextLine; // One definition list can contain multiple DTs,\n  // and one DT can be followed by multiple DDs.\n  //\n  // Thus, there is two loops here, and label is\n  // needed to break out of the second one\n  //\n\n  /*eslint no-labels:0,block-scoped-var:0*/\n\n  OUTER: for (;;) {\n    tight = true;\n    prevEmptyEnd = false;\n    state.tokens.push({\n      type: 'dt_open',\n      lines: [dtLine, dtLine],\n      level: state.level++\n    });\n    state.tokens.push({\n      type: 'inline',\n      content: state.getLines(dtLine, dtLine + 1, state.blkIndent, false).trim(),\n      level: state.level + 1,\n      lines: [dtLine, dtLine],\n      children: []\n    });\n    state.tokens.push({\n      type: 'dt_close',\n      level: --state.level\n    });\n\n    for (;;) {\n      state.tokens.push({\n        type: 'dd_open',\n        lines: itemLines = [nextLine, 0],\n        level: state.level++\n      });\n      oldTight = state.tight;\n      oldDDIndent = state.ddIndent;\n      oldIndent = state.blkIndent;\n      oldTShift = state.tShift[ddLine];\n      oldParentType = state.parentType;\n      state.blkIndent = state.ddIndent = state.tShift[ddLine] + 2;\n      state.tShift[ddLine] = contentStart - state.bMarks[ddLine];\n      state.tight = true;\n      state.parentType = 'deflist';\n      state.parser.tokenize(state, ddLine, endLine, true); // If any of list item is tight, mark list as tight\n\n      if (!state.tight || prevEmptyEnd) {\n        tight = false;\n      } // Item become loose if finish with empty line,\n      // but we should filter last element, because it means list finish\n\n\n      prevEmptyEnd = state.line - ddLine > 1 && state.isEmpty(state.line - 1);\n      state.tShift[ddLine] = oldTShift;\n      state.tight = oldTight;\n      state.parentType = oldParentType;\n      state.blkIndent = oldIndent;\n      state.ddIndent = oldDDIndent;\n      state.tokens.push({\n        type: 'dd_close',\n        level: --state.level\n      });\n      itemLines[1] = nextLine = state.line;\n\n      if (nextLine >= endLine) {\n        break OUTER;\n      }\n\n      if (state.tShift[nextLine] < state.blkIndent) {\n        break OUTER;\n      }\n\n      contentStart = skipMarker(state, nextLine);\n\n      if (contentStart < 0) {\n        break;\n      }\n\n      ddLine = nextLine; // go to the next loop iteration:\n      // insert DD tag and repeat checking\n    }\n\n    if (nextLine >= endLine) {\n      break;\n    }\n\n    dtLine = nextLine;\n\n    if (state.isEmpty(dtLine)) {\n      break;\n    }\n\n    if (state.tShift[dtLine] < state.blkIndent) {\n      break;\n    }\n\n    ddLine = dtLine + 1;\n\n    if (ddLine >= endLine) {\n      break;\n    }\n\n    if (state.isEmpty(ddLine)) {\n      ddLine++;\n    }\n\n    if (ddLine >= endLine) {\n      break;\n    }\n\n    if (state.tShift[ddLine] < state.blkIndent) {\n      break;\n    }\n\n    contentStart = skipMarker(state, ddLine);\n\n    if (contentStart < 0) {\n      break;\n    } // go to the next loop iteration:\n    // insert DT and DD tags and repeat checking\n\n  } // Finilize list\n\n\n  state.tokens.push({\n    type: 'dl_close',\n    level: --state.level\n  });\n  listLines[1] = nextLine;\n  state.line = nextLine; // mark paragraphs tight if needed\n\n  if (tight) {\n    markTightParagraphs(state, listTokIdx);\n  }\n\n  return true;\n};","map":{"version":3,"names":["skipMarker","state","line","pos","marker","start","bMarks","tShift","max","eMarks","src","charCodeAt","skipSpaces","markTightParagraphs","idx","i","l","level","tokens","length","type","tight","module","exports","deflist","startLine","endLine","silent","contentStart","ddLine","dtLine","itemLines","listLines","listTokIdx","nextLine","oldIndent","oldDDIndent","oldParentType","oldTShift","oldTight","prevEmptyEnd","ddIndent","isEmpty","blkIndent","options","maxNesting","push","lines","OUTER","content","getLines","trim","children","parentType","parser","tokenize"],"sources":["C:/Users/caoma/Downloads/another/online-shop/node_modules/remarkable/lib/rules_block/deflist.js"],"sourcesContent":["// Definition lists\n\n'use strict';\n\n\n// Search `[:~][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\nfunction skipMarker(state, line) {\n  var pos, marker,\n      start = state.bMarks[line] + state.tShift[line],\n      max = state.eMarks[line];\n\n  if (start >= max) { return -1; }\n\n  // Check bullet\n  marker = state.src.charCodeAt(start++);\n  if (marker !== 0x7E/* ~ */ && marker !== 0x3A/* : */) { return -1; }\n\n  pos = state.skipSpaces(start);\n\n  // require space after \":\"\n  if (start === pos) { return -1; }\n\n  // no empty definitions, e.g. \"  : \"\n  if (pos >= max) { return -1; }\n\n  return pos;\n}\n\nfunction markTightParagraphs(state, idx) {\n  var i, l,\n      level = state.level + 2;\n\n  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n      state.tokens[i + 2].tight = true;\n      state.tokens[i].tight = true;\n      i += 2;\n    }\n  }\n}\n\nmodule.exports = function deflist(state, startLine, endLine, silent) {\n  var contentStart,\n      ddLine,\n      dtLine,\n      itemLines,\n      listLines,\n      listTokIdx,\n      nextLine,\n      oldIndent,\n      oldDDIndent,\n      oldParentType,\n      oldTShift,\n      oldTight,\n      prevEmptyEnd,\n      tight;\n\n  if (silent) {\n    // quirk: validation mode validates a dd block only, not a whole deflist\n    if (state.ddIndent < 0) { return false; }\n    return skipMarker(state, startLine) >= 0;\n  }\n\n  nextLine = startLine + 1;\n  if (state.isEmpty(nextLine)) {\n    if (++nextLine > endLine) { return false; }\n  }\n\n  if (state.tShift[nextLine] < state.blkIndent) { return false; }\n  contentStart = skipMarker(state, nextLine);\n  if (contentStart < 0) { return false; }\n\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  // Start list\n  listTokIdx = state.tokens.length;\n\n  state.tokens.push({\n    type: 'dl_open',\n    lines: listLines = [ startLine, 0 ],\n    level: state.level++\n  });\n\n  //\n  // Iterate list items\n  //\n\n  dtLine = startLine;\n  ddLine = nextLine;\n\n  // One definition list can contain multiple DTs,\n  // and one DT can be followed by multiple DDs.\n  //\n  // Thus, there is two loops here, and label is\n  // needed to break out of the second one\n  //\n  /*eslint no-labels:0,block-scoped-var:0*/\n  OUTER:\n  for (;;) {\n    tight = true;\n    prevEmptyEnd = false;\n\n    state.tokens.push({\n      type: 'dt_open',\n      lines: [ dtLine, dtLine ],\n      level: state.level++\n    });\n    state.tokens.push({\n      type: 'inline',\n      content: state.getLines(dtLine, dtLine + 1, state.blkIndent, false).trim(),\n      level: state.level + 1,\n      lines: [ dtLine, dtLine ],\n      children: []\n    });\n    state.tokens.push({\n      type: 'dt_close',\n      level: --state.level\n    });\n\n    for (;;) {\n      state.tokens.push({\n        type: 'dd_open',\n        lines: itemLines = [ nextLine, 0 ],\n        level: state.level++\n      });\n\n      oldTight = state.tight;\n      oldDDIndent = state.ddIndent;\n      oldIndent = state.blkIndent;\n      oldTShift = state.tShift[ddLine];\n      oldParentType = state.parentType;\n      state.blkIndent = state.ddIndent = state.tShift[ddLine] + 2;\n      state.tShift[ddLine] = contentStart - state.bMarks[ddLine];\n      state.tight = true;\n      state.parentType = 'deflist';\n\n      state.parser.tokenize(state, ddLine, endLine, true);\n\n      // If any of list item is tight, mark list as tight\n      if (!state.tight || prevEmptyEnd) {\n        tight = false;\n      }\n      // Item become loose if finish with empty line,\n      // but we should filter last element, because it means list finish\n      prevEmptyEnd = (state.line - ddLine) > 1 && state.isEmpty(state.line - 1);\n\n      state.tShift[ddLine] = oldTShift;\n      state.tight = oldTight;\n      state.parentType = oldParentType;\n      state.blkIndent = oldIndent;\n      state.ddIndent = oldDDIndent;\n\n      state.tokens.push({\n        type: 'dd_close',\n        level: --state.level\n      });\n\n      itemLines[1] = nextLine = state.line;\n\n      if (nextLine >= endLine) { break OUTER; }\n\n      if (state.tShift[nextLine] < state.blkIndent) { break OUTER; }\n      contentStart = skipMarker(state, nextLine);\n      if (contentStart < 0) { break; }\n\n      ddLine = nextLine;\n\n      // go to the next loop iteration:\n      // insert DD tag and repeat checking\n    }\n\n    if (nextLine >= endLine) { break; }\n    dtLine = nextLine;\n\n    if (state.isEmpty(dtLine)) { break; }\n    if (state.tShift[dtLine] < state.blkIndent) { break; }\n\n    ddLine = dtLine + 1;\n    if (ddLine >= endLine) { break; }\n    if (state.isEmpty(ddLine)) { ddLine++; }\n    if (ddLine >= endLine) { break; }\n\n    if (state.tShift[ddLine] < state.blkIndent) { break; }\n    contentStart = skipMarker(state, ddLine);\n    if (contentStart < 0) { break; }\n\n    // go to the next loop iteration:\n    // insert DT and DD tags and repeat checking\n  }\n\n  // Finilize list\n  state.tokens.push({\n    type: 'dl_close',\n    level: --state.level\n  });\n  listLines[1] = nextLine;\n\n  state.line = nextLine;\n\n  // mark paragraphs tight if needed\n  if (tight) {\n    markTightParagraphs(state, listTokIdx);\n  }\n\n  return true;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}