{"ast":null,"code":"'use strict';\n/**\n * Parse link labels\n *\n * This function assumes that first character (`[`) already matches;\n * returns the end of the label.\n *\n * @param  {Object} state\n * @param  {Number} start\n * @api private\n */\n\nmodule.exports = function parseLinkLabel(state, start) {\n  var level,\n      found,\n      marker,\n      labelEnd = -1,\n      max = state.posMax,\n      oldPos = state.pos,\n      oldFlag = state.isInLabel;\n\n  if (state.isInLabel) {\n    return -1;\n  }\n\n  if (state.labelUnmatchedScopes) {\n    state.labelUnmatchedScopes--;\n    return -1;\n  }\n\n  state.pos = start + 1;\n  state.isInLabel = true;\n  level = 1;\n\n  while (state.pos < max) {\n    marker = state.src.charCodeAt(state.pos);\n\n    if (marker === 0x5B\n    /* [ */\n    ) {\n      level++;\n    } else if (marker === 0x5D\n    /* ] */\n    ) {\n      level--;\n\n      if (level === 0) {\n        found = true;\n        break;\n      }\n    }\n\n    state.parser.skipToken(state);\n  }\n\n  if (found) {\n    labelEnd = state.pos;\n    state.labelUnmatchedScopes = 0;\n  } else {\n    state.labelUnmatchedScopes = level - 1;\n  } // restore old state\n\n\n  state.pos = oldPos;\n  state.isInLabel = oldFlag;\n  return labelEnd;\n};","map":{"version":3,"names":["module","exports","parseLinkLabel","state","start","level","found","marker","labelEnd","max","posMax","oldPos","pos","oldFlag","isInLabel","labelUnmatchedScopes","src","charCodeAt","parser","skipToken"],"sources":["C:/Users/caoma/Downloads/online-shop/node_modules/remarkable/lib/helpers/parse_link_label.js"],"sourcesContent":["'use strict';\n\n/**\n * Parse link labels\n *\n * This function assumes that first character (`[`) already matches;\n * returns the end of the label.\n *\n * @param  {Object} state\n * @param  {Number} start\n * @api private\n */\n\nmodule.exports = function parseLinkLabel(state, start) {\n  var level, found, marker,\n      labelEnd = -1,\n      max = state.posMax,\n      oldPos = state.pos,\n      oldFlag = state.isInLabel;\n\n  if (state.isInLabel) { return -1; }\n\n  if (state.labelUnmatchedScopes) {\n    state.labelUnmatchedScopes--;\n    return -1;\n  }\n\n  state.pos = start + 1;\n  state.isInLabel = true;\n  level = 1;\n\n  while (state.pos < max) {\n    marker = state.src.charCodeAt(state.pos);\n    if (marker === 0x5B /* [ */) {\n      level++;\n    } else if (marker === 0x5D /* ] */) {\n      level--;\n      if (level === 0) {\n        found = true;\n        break;\n      }\n    }\n\n    state.parser.skipToken(state);\n  }\n\n  if (found) {\n    labelEnd = state.pos;\n    state.labelUnmatchedScopes = 0;\n  } else {\n    state.labelUnmatchedScopes = level - 1;\n  }\n\n  // restore old state\n  state.pos = oldPos;\n  state.isInLabel = oldFlag;\n\n  return labelEnd;\n};\n"],"mappings":"AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAA,MAAM,CAACC,OAAP,GAAiB,SAASC,cAAT,CAAwBC,KAAxB,EAA+BC,KAA/B,EAAsC;EACrD,IAAIC,KAAJ;EAAA,IAAWC,KAAX;EAAA,IAAkBC,MAAlB;EAAA,IACIC,QAAQ,GAAG,CAAC,CADhB;EAAA,IAEIC,GAAG,GAAGN,KAAK,CAACO,MAFhB;EAAA,IAGIC,MAAM,GAAGR,KAAK,CAACS,GAHnB;EAAA,IAIIC,OAAO,GAAGV,KAAK,CAACW,SAJpB;;EAMA,IAAIX,KAAK,CAACW,SAAV,EAAqB;IAAE,OAAO,CAAC,CAAR;EAAY;;EAEnC,IAAIX,KAAK,CAACY,oBAAV,EAAgC;IAC9BZ,KAAK,CAACY,oBAAN;IACA,OAAO,CAAC,CAAR;EACD;;EAEDZ,KAAK,CAACS,GAAN,GAAYR,KAAK,GAAG,CAApB;EACAD,KAAK,CAACW,SAAN,GAAkB,IAAlB;EACAT,KAAK,GAAG,CAAR;;EAEA,OAAOF,KAAK,CAACS,GAAN,GAAYH,GAAnB,EAAwB;IACtBF,MAAM,GAAGJ,KAAK,CAACa,GAAN,CAAUC,UAAV,CAAqBd,KAAK,CAACS,GAA3B,CAAT;;IACA,IAAIL,MAAM,KAAK;IAAK;IAApB,EAA6B;MAC3BF,KAAK;IACN,CAFD,MAEO,IAAIE,MAAM,KAAK;IAAK;IAApB,EAA6B;MAClCF,KAAK;;MACL,IAAIA,KAAK,KAAK,CAAd,EAAiB;QACfC,KAAK,GAAG,IAAR;QACA;MACD;IACF;;IAEDH,KAAK,CAACe,MAAN,CAAaC,SAAb,CAAuBhB,KAAvB;EACD;;EAED,IAAIG,KAAJ,EAAW;IACTE,QAAQ,GAAGL,KAAK,CAACS,GAAjB;IACAT,KAAK,CAACY,oBAAN,GAA6B,CAA7B;EACD,CAHD,MAGO;IACLZ,KAAK,CAACY,oBAAN,GAA6BV,KAAK,GAAG,CAArC;EACD,CAtCoD,CAwCrD;;;EACAF,KAAK,CAACS,GAAN,GAAYD,MAAZ;EACAR,KAAK,CAACW,SAAN,GAAkBD,OAAlB;EAEA,OAAOL,QAAP;AACD,CA7CD"},"metadata":{},"sourceType":"script"}