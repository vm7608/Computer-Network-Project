{"ast":null,"code":"// fences (``` lang, ~~~ lang)\n'use strict';\n\nmodule.exports = function fences(state, startLine, endLine, silent) {\n  var marker,\n      len,\n      params,\n      nextLine,\n      mem,\n      haveEndMarker = false,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  if (pos + 3 > max) {\n    return false;\n  }\n\n  marker = state.src.charCodeAt(pos);\n\n  if (marker !== 0x7E\n  /* ~ */\n  && marker !== 0x60\n  /* ` */\n  ) {\n    return false;\n  } // scan marker length\n\n\n  mem = pos;\n  pos = state.skipChars(pos, marker);\n  len = pos - mem;\n\n  if (len < 3) {\n    return false;\n  }\n\n  params = state.src.slice(pos, max).trim();\n\n  if (params.indexOf('`') >= 0) {\n    return false;\n  } // Since start is found, we can report success here in validation mode\n\n\n  if (silent) {\n    return true;\n  } // search end of block\n\n\n  nextLine = startLine;\n\n  for (;;) {\n    nextLine++;\n\n    if (nextLine >= endLine) {\n      // unclosed block should be autoclosed by end of document.\n      // also block seems to be autoclosed by end of parent\n      break;\n    }\n\n    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n\n    if (pos < max && state.tShift[nextLine] < state.blkIndent) {\n      // non-empty line with negative indent should stop the list:\n      // - ```\n      //  test\n      break;\n    }\n\n    if (state.src.charCodeAt(pos) !== marker) {\n      continue;\n    }\n\n    if (state.tShift[nextLine] - state.blkIndent >= 4) {\n      // closing fence should be indented less than 4 spaces\n      continue;\n    }\n\n    pos = state.skipChars(pos, marker); // closing code fence must be at least as long as the opening one\n\n    if (pos - mem < len) {\n      continue;\n    } // make sure tail has spaces only\n\n\n    pos = state.skipSpaces(pos);\n\n    if (pos < max) {\n      continue;\n    }\n\n    haveEndMarker = true; // found!\n\n    break;\n  } // If a fence has heading spaces, they should be removed from its inner block\n\n\n  len = state.tShift[startLine];\n  state.line = nextLine + (haveEndMarker ? 1 : 0);\n  state.tokens.push({\n    type: 'fence',\n    params: params,\n    content: state.getLines(startLine + 1, nextLine, len, true),\n    lines: [startLine, state.line],\n    level: state.level\n  });\n  return true;\n};","map":{"version":3,"names":["module","exports","fences","state","startLine","endLine","silent","marker","len","params","nextLine","mem","haveEndMarker","pos","bMarks","tShift","max","eMarks","src","charCodeAt","skipChars","slice","trim","indexOf","blkIndent","skipSpaces","line","tokens","push","type","content","getLines","lines","level"],"sources":["C:/Users/caoma/Downloads/online-shop/node_modules/remarkable/lib/rules_block/fences.js"],"sourcesContent":["// fences (``` lang, ~~~ lang)\n\n'use strict';\n\n\nmodule.exports = function fences(state, startLine, endLine, silent) {\n  var marker, len, params, nextLine, mem,\n      haveEndMarker = false,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  if (pos + 3 > max) { return false; }\n\n  marker = state.src.charCodeAt(pos);\n\n  if (marker !== 0x7E/* ~ */ && marker !== 0x60 /* ` */) {\n    return false;\n  }\n\n  // scan marker length\n  mem = pos;\n  pos = state.skipChars(pos, marker);\n\n  len = pos - mem;\n\n  if (len < 3) { return false; }\n\n  params = state.src.slice(pos, max).trim();\n\n  if (params.indexOf('`') >= 0) { return false; }\n\n  // Since start is found, we can report success here in validation mode\n  if (silent) { return true; }\n\n  // search end of block\n  nextLine = startLine;\n\n  for (;;) {\n    nextLine++;\n    if (nextLine >= endLine) {\n      // unclosed block should be autoclosed by end of document.\n      // also block seems to be autoclosed by end of parent\n      break;\n    }\n\n    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n\n    if (pos < max && state.tShift[nextLine] < state.blkIndent) {\n      // non-empty line with negative indent should stop the list:\n      // - ```\n      //  test\n      break;\n    }\n\n    if (state.src.charCodeAt(pos) !== marker) { continue; }\n\n    if (state.tShift[nextLine] - state.blkIndent >= 4) {\n      // closing fence should be indented less than 4 spaces\n      continue;\n    }\n\n    pos = state.skipChars(pos, marker);\n\n    // closing code fence must be at least as long as the opening one\n    if (pos - mem < len) { continue; }\n\n    // make sure tail has spaces only\n    pos = state.skipSpaces(pos);\n\n    if (pos < max) { continue; }\n\n    haveEndMarker = true;\n    // found!\n    break;\n  }\n\n  // If a fence has heading spaces, they should be removed from its inner block\n  len = state.tShift[startLine];\n\n  state.line = nextLine + (haveEndMarker ? 1 : 0);\n  state.tokens.push({\n    type: 'fence',\n    params: params,\n    content: state.getLines(startLine + 1, nextLine, len, true),\n    lines: [ startLine, state.line ],\n    level: state.level\n  });\n\n  return true;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}