{"ast":null,"code":"// Process *this* and _that_\n'use strict';\n\nfunction isAlphaNum(code) {\n  return code >= 0x30\n  /* 0 */\n  && code <= 0x39\n  /* 9 */\n  || code >= 0x41\n  /* A */\n  && code <= 0x5A\n  /* Z */\n  || code >= 0x61\n  /* a */\n  && code <= 0x7A\n  /* z */\n  ;\n} // parse sequence of emphasis markers,\n// \"start\" should point at a valid marker\n\n\nfunction scanDelims(state, start) {\n  var pos = start,\n      lastChar,\n      nextChar,\n      count,\n      can_open = true,\n      can_close = true,\n      max = state.posMax,\n      marker = state.src.charCodeAt(start);\n  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;\n\n  while (pos < max && state.src.charCodeAt(pos) === marker) {\n    pos++;\n  }\n\n  if (pos >= max) {\n    can_open = false;\n  }\n\n  count = pos - start;\n\n  if (count >= 4) {\n    // sequence of four or more unescaped markers can't start/end an emphasis\n    can_open = can_close = false;\n  } else {\n    nextChar = pos < max ? state.src.charCodeAt(pos) : -1; // check whitespace conditions\n\n    if (nextChar === 0x20 || nextChar === 0x0A) {\n      can_open = false;\n    }\n\n    if (lastChar === 0x20 || lastChar === 0x0A) {\n      can_close = false;\n    }\n\n    if (marker === 0x5F\n    /* _ */\n    ) {\n      // check if we aren't inside the word\n      if (isAlphaNum(lastChar)) {\n        can_open = false;\n      }\n\n      if (isAlphaNum(nextChar)) {\n        can_close = false;\n      }\n    }\n  }\n\n  return {\n    can_open: can_open,\n    can_close: can_close,\n    delims: count\n  };\n}\n\nmodule.exports = function emphasis(state, silent) {\n  var startCount,\n      count,\n      found,\n      oldCount,\n      newCount,\n      stack,\n      res,\n      max = state.posMax,\n      start = state.pos,\n      marker = state.src.charCodeAt(start);\n\n  if (marker !== 0x5F\n  /* _ */\n  && marker !== 0x2A\n  /* * */\n  ) {\n    return false;\n  }\n\n  if (silent) {\n    return false;\n  } // don't run any pairs in validation mode\n\n\n  res = scanDelims(state, start);\n  startCount = res.delims;\n\n  if (!res.can_open) {\n    state.pos += startCount;\n\n    if (!silent) {\n      state.pending += state.src.slice(start, state.pos);\n    }\n\n    return true;\n  }\n\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  }\n\n  state.pos = start + startCount;\n  stack = [startCount];\n\n  while (state.pos < max) {\n    if (state.src.charCodeAt(state.pos) === marker) {\n      res = scanDelims(state, state.pos);\n      count = res.delims;\n\n      if (res.can_close) {\n        oldCount = stack.pop();\n        newCount = count;\n\n        while (oldCount !== newCount) {\n          if (newCount < oldCount) {\n            stack.push(oldCount - newCount);\n            break;\n          } // assert(newCount > oldCount)\n\n\n          newCount -= oldCount;\n\n          if (stack.length === 0) {\n            break;\n          }\n\n          state.pos += oldCount;\n          oldCount = stack.pop();\n        }\n\n        if (stack.length === 0) {\n          startCount = oldCount;\n          found = true;\n          break;\n        }\n\n        state.pos += count;\n        continue;\n      }\n\n      if (res.can_open) {\n        stack.push(count);\n      }\n\n      state.pos += count;\n      continue;\n    }\n\n    state.parser.skipToken(state);\n  }\n\n  if (!found) {\n    // parser failed to find ending tag, so it's not valid emphasis\n    state.pos = start;\n    return false;\n  } // found!\n\n\n  state.posMax = state.pos;\n  state.pos = start + startCount;\n\n  if (!silent) {\n    if (startCount === 2 || startCount === 3) {\n      state.push({\n        type: 'strong_open',\n        level: state.level++\n      });\n    }\n\n    if (startCount === 1 || startCount === 3) {\n      state.push({\n        type: 'em_open',\n        level: state.level++\n      });\n    }\n\n    state.parser.tokenize(state);\n\n    if (startCount === 1 || startCount === 3) {\n      state.push({\n        type: 'em_close',\n        level: --state.level\n      });\n    }\n\n    if (startCount === 2 || startCount === 3) {\n      state.push({\n        type: 'strong_close',\n        level: --state.level\n      });\n    }\n  }\n\n  state.pos = state.posMax + startCount;\n  state.posMax = max;\n  return true;\n};","map":{"version":3,"names":["isAlphaNum","code","scanDelims","state","start","pos","lastChar","nextChar","count","can_open","can_close","max","posMax","marker","src","charCodeAt","delims","module","exports","emphasis","silent","startCount","found","oldCount","newCount","stack","res","pending","slice","level","options","maxNesting","pop","push","length","parser","skipToken","type","tokenize"],"sources":["C:/Users/caoma/Downloads/online-shop/node_modules/remarkable/lib/rules_inline/emphasis.js"],"sourcesContent":["// Process *this* and _that_\n\n'use strict';\n\n\nfunction isAlphaNum(code) {\n  return (code >= 0x30 /* 0 */ && code <= 0x39 /* 9 */) ||\n         (code >= 0x41 /* A */ && code <= 0x5A /* Z */) ||\n         (code >= 0x61 /* a */ && code <= 0x7A /* z */);\n}\n\n// parse sequence of emphasis markers,\n// \"start\" should point at a valid marker\nfunction scanDelims(state, start) {\n  var pos = start, lastChar, nextChar, count,\n      can_open = true,\n      can_close = true,\n      max = state.posMax,\n      marker = state.src.charCodeAt(start);\n\n  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;\n\n  while (pos < max && state.src.charCodeAt(pos) === marker) { pos++; }\n  if (pos >= max) { can_open = false; }\n  count = pos - start;\n\n  if (count >= 4) {\n    // sequence of four or more unescaped markers can't start/end an emphasis\n    can_open = can_close = false;\n  } else {\n    nextChar = pos < max ? state.src.charCodeAt(pos) : -1;\n\n    // check whitespace conditions\n    if (nextChar === 0x20 || nextChar === 0x0A) { can_open = false; }\n    if (lastChar === 0x20 || lastChar === 0x0A) { can_close = false; }\n\n    if (marker === 0x5F /* _ */) {\n      // check if we aren't inside the word\n      if (isAlphaNum(lastChar)) { can_open = false; }\n      if (isAlphaNum(nextChar)) { can_close = false; }\n    }\n  }\n\n  return {\n    can_open: can_open,\n    can_close: can_close,\n    delims: count\n  };\n}\n\nmodule.exports = function emphasis(state, silent) {\n  var startCount,\n      count,\n      found,\n      oldCount,\n      newCount,\n      stack,\n      res,\n      max = state.posMax,\n      start = state.pos,\n      marker = state.src.charCodeAt(start);\n\n  if (marker !== 0x5F/* _ */ && marker !== 0x2A /* * */) { return false; }\n  if (silent) { return false; } // don't run any pairs in validation mode\n\n  res = scanDelims(state, start);\n  startCount = res.delims;\n  if (!res.can_open) {\n    state.pos += startCount;\n    if (!silent) { state.pending += state.src.slice(start, state.pos); }\n    return true;\n  }\n\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  state.pos = start + startCount;\n  stack = [ startCount ];\n\n  while (state.pos < max) {\n    if (state.src.charCodeAt(state.pos) === marker) {\n      res = scanDelims(state, state.pos);\n      count = res.delims;\n      if (res.can_close) {\n        oldCount = stack.pop();\n        newCount = count;\n\n        while (oldCount !== newCount) {\n          if (newCount < oldCount) {\n            stack.push(oldCount - newCount);\n            break;\n          }\n\n          // assert(newCount > oldCount)\n          newCount -= oldCount;\n\n          if (stack.length === 0) { break; }\n          state.pos += oldCount;\n          oldCount = stack.pop();\n        }\n\n        if (stack.length === 0) {\n          startCount = oldCount;\n          found = true;\n          break;\n        }\n        state.pos += count;\n        continue;\n      }\n\n      if (res.can_open) { stack.push(count); }\n      state.pos += count;\n      continue;\n    }\n\n    state.parser.skipToken(state);\n  }\n\n  if (!found) {\n    // parser failed to find ending tag, so it's not valid emphasis\n    state.pos = start;\n    return false;\n  }\n\n  // found!\n  state.posMax = state.pos;\n  state.pos = start + startCount;\n\n  if (!silent) {\n    if (startCount === 2 || startCount === 3) {\n      state.push({ type: 'strong_open', level: state.level++ });\n    }\n    if (startCount === 1 || startCount === 3) {\n      state.push({ type: 'em_open', level: state.level++ });\n    }\n\n    state.parser.tokenize(state);\n\n    if (startCount === 1 || startCount === 3) {\n      state.push({ type: 'em_close', level: --state.level });\n    }\n    if (startCount === 2 || startCount === 3) {\n      state.push({ type: 'strong_close', level: --state.level });\n    }\n  }\n\n  state.pos = state.posMax + startCount;\n  state.posMax = max;\n  return true;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}