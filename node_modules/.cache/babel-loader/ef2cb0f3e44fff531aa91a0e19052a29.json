{"ast":null,"code":"// Block quotes\n'use strict';\n\nmodule.exports = function blockquote(state, startLine, endLine, silent) {\n  var nextLine,\n      lastLineEmpty,\n      oldTShift,\n      oldBMarks,\n      oldIndent,\n      oldParentType,\n      lines,\n      terminatorRules,\n      i,\n      l,\n      terminate,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  if (pos > max) {\n    return false;\n  } // check the block quote marker\n\n\n  if (state.src.charCodeAt(pos++) !== 0x3E\n  /* > */\n  ) {\n    return false;\n  }\n\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  } // we know that it's going to be a valid blockquote,\n  // so no point trying to find the end of it in silent mode\n\n\n  if (silent) {\n    return true;\n  } // skip one optional space after '>'\n\n\n  if (state.src.charCodeAt(pos) === 0x20) {\n    pos++;\n  }\n\n  oldIndent = state.blkIndent;\n  state.blkIndent = 0;\n  oldBMarks = [state.bMarks[startLine]];\n  state.bMarks[startLine] = pos; // check if we have an empty blockquote\n\n  pos = pos < max ? state.skipSpaces(pos) : pos;\n  lastLineEmpty = pos >= max;\n  oldTShift = [state.tShift[startLine]];\n  state.tShift[startLine] = pos - state.bMarks[startLine];\n  terminatorRules = state.parser.ruler.getRules('blockquote'); // Search the end of the block\n  //\n  // Block ends with either:\n  //  1. an empty line outside:\n  //     ```\n  //     > test\n  //\n  //     ```\n  //  2. an empty line inside:\n  //     ```\n  //     >\n  //     test\n  //     ```\n  //  3. another tag\n  //     ```\n  //     > test\n  //      - - -\n  //     ```\n\n  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {\n    pos = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n\n    if (pos >= max) {\n      // Case 1: line is not inside the blockquote, and this line is empty.\n      break;\n    }\n\n    if (state.src.charCodeAt(pos++) === 0x3E\n    /* > */\n    ) {\n      // This line is inside the blockquote.\n      // skip one optional space after '>'\n      if (state.src.charCodeAt(pos) === 0x20) {\n        pos++;\n      }\n\n      oldBMarks.push(state.bMarks[nextLine]);\n      state.bMarks[nextLine] = pos;\n      pos = pos < max ? state.skipSpaces(pos) : pos;\n      lastLineEmpty = pos >= max;\n      oldTShift.push(state.tShift[nextLine]);\n      state.tShift[nextLine] = pos - state.bMarks[nextLine];\n      continue;\n    } // Case 2: line is not inside the blockquote, and the last line was empty.\n\n\n    if (lastLineEmpty) {\n      break;\n    } // Case 3: another tag found.\n\n\n    terminate = false;\n\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n\n    if (terminate) {\n      break;\n    }\n\n    oldBMarks.push(state.bMarks[nextLine]);\n    oldTShift.push(state.tShift[nextLine]); // A negative number means that this is a paragraph continuation;\n    //\n    // Any negative number will do the job here, but it's better for it\n    // to be large enough to make any bugs obvious.\n\n    state.tShift[nextLine] = -1337;\n  }\n\n  oldParentType = state.parentType;\n  state.parentType = 'blockquote';\n  state.tokens.push({\n    type: 'blockquote_open',\n    lines: lines = [startLine, 0],\n    level: state.level++\n  });\n  state.parser.tokenize(state, startLine, nextLine);\n  state.tokens.push({\n    type: 'blockquote_close',\n    level: --state.level\n  });\n  state.parentType = oldParentType;\n  lines[1] = state.line; // Restore original tShift; this might not be necessary since the parser\n  // has already been here, but just to make sure we can do that.\n\n  for (i = 0; i < oldTShift.length; i++) {\n    state.bMarks[i + startLine] = oldBMarks[i];\n    state.tShift[i + startLine] = oldTShift[i];\n  }\n\n  state.blkIndent = oldIndent;\n  return true;\n};","map":{"version":3,"names":["module","exports","blockquote","state","startLine","endLine","silent","nextLine","lastLineEmpty","oldTShift","oldBMarks","oldIndent","oldParentType","lines","terminatorRules","i","l","terminate","pos","bMarks","tShift","max","eMarks","src","charCodeAt","level","options","maxNesting","blkIndent","skipSpaces","parser","ruler","getRules","push","length","parentType","tokens","type","tokenize","line"],"sources":["C:/Users/caoma/Downloads/another/online-shop/node_modules/remarkable/lib/rules_block/blockquote.js"],"sourcesContent":["// Block quotes\n\n'use strict';\n\n\nmodule.exports = function blockquote(state, startLine, endLine, silent) {\n  var nextLine, lastLineEmpty, oldTShift, oldBMarks, oldIndent, oldParentType, lines,\n      terminatorRules,\n      i, l, terminate,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  if (pos > max) { return false; }\n\n  // check the block quote marker\n  if (state.src.charCodeAt(pos++) !== 0x3E/* > */) { return false; }\n\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  // we know that it's going to be a valid blockquote,\n  // so no point trying to find the end of it in silent mode\n  if (silent) { return true; }\n\n  // skip one optional space after '>'\n  if (state.src.charCodeAt(pos) === 0x20) { pos++; }\n\n  oldIndent = state.blkIndent;\n  state.blkIndent = 0;\n\n  oldBMarks = [ state.bMarks[startLine] ];\n  state.bMarks[startLine] = pos;\n\n  // check if we have an empty blockquote\n  pos = pos < max ? state.skipSpaces(pos) : pos;\n  lastLineEmpty = pos >= max;\n\n  oldTShift = [ state.tShift[startLine] ];\n  state.tShift[startLine] = pos - state.bMarks[startLine];\n\n  terminatorRules = state.parser.ruler.getRules('blockquote');\n\n  // Search the end of the block\n  //\n  // Block ends with either:\n  //  1. an empty line outside:\n  //     ```\n  //     > test\n  //\n  //     ```\n  //  2. an empty line inside:\n  //     ```\n  //     >\n  //     test\n  //     ```\n  //  3. another tag\n  //     ```\n  //     > test\n  //      - - -\n  //     ```\n  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {\n    pos = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n\n    if (pos >= max) {\n      // Case 1: line is not inside the blockquote, and this line is empty.\n      break;\n    }\n\n    if (state.src.charCodeAt(pos++) === 0x3E/* > */) {\n      // This line is inside the blockquote.\n\n      // skip one optional space after '>'\n      if (state.src.charCodeAt(pos) === 0x20) { pos++; }\n\n      oldBMarks.push(state.bMarks[nextLine]);\n      state.bMarks[nextLine] = pos;\n\n      pos = pos < max ? state.skipSpaces(pos) : pos;\n      lastLineEmpty = pos >= max;\n\n      oldTShift.push(state.tShift[nextLine]);\n      state.tShift[nextLine] = pos - state.bMarks[nextLine];\n      continue;\n    }\n\n    // Case 2: line is not inside the blockquote, and the last line was empty.\n    if (lastLineEmpty) { break; }\n\n    // Case 3: another tag found.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n\n    oldBMarks.push(state.bMarks[nextLine]);\n    oldTShift.push(state.tShift[nextLine]);\n\n    // A negative number means that this is a paragraph continuation;\n    //\n    // Any negative number will do the job here, but it's better for it\n    // to be large enough to make any bugs obvious.\n    state.tShift[nextLine] = -1337;\n  }\n\n  oldParentType = state.parentType;\n  state.parentType = 'blockquote';\n  state.tokens.push({\n    type: 'blockquote_open',\n    lines: lines = [ startLine, 0 ],\n    level: state.level++\n  });\n  state.parser.tokenize(state, startLine, nextLine);\n  state.tokens.push({\n    type: 'blockquote_close',\n    level: --state.level\n  });\n  state.parentType = oldParentType;\n  lines[1] = state.line;\n\n  // Restore original tShift; this might not be necessary since the parser\n  // has already been here, but just to make sure we can do that.\n  for (i = 0; i < oldTShift.length; i++) {\n    state.bMarks[i + startLine] = oldBMarks[i];\n    state.tShift[i + startLine] = oldTShift[i];\n  }\n  state.blkIndent = oldIndent;\n\n  return true;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}