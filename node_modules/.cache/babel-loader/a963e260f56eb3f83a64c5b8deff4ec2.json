{"ast":null,"code":"// Lists\n'use strict'; // Search `[-+*][\\n ]`, returns next pos arter marker on success\n// or -1 on fail.\n\nfunction skipBulletListMarker(state, startLine) {\n  var marker, pos, max;\n  pos = state.bMarks[startLine] + state.tShift[startLine];\n  max = state.eMarks[startLine];\n\n  if (pos >= max) {\n    return -1;\n  }\n\n  marker = state.src.charCodeAt(pos++); // Check bullet\n\n  if (marker !== 0x2A\n  /* * */\n  && marker !== 0x2D\n  /* - */\n  && marker !== 0x2B\n  /* + */\n  ) {\n    return -1;\n  }\n\n  if (pos < max && state.src.charCodeAt(pos) !== 0x20) {\n    // \" 1.test \" - is not a list item\n    return -1;\n  }\n\n  return pos;\n} // Search `\\d+[.)][\\n ]`, returns next pos arter marker on success\n// or -1 on fail.\n\n\nfunction skipOrderedListMarker(state, startLine) {\n  var ch,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  if (pos + 1 >= max) {\n    return -1;\n  }\n\n  ch = state.src.charCodeAt(pos++);\n\n  if (ch < 0x30\n  /* 0 */\n  || ch > 0x39\n  /* 9 */\n  ) {\n    return -1;\n  }\n\n  for (;;) {\n    // EOL -> fail\n    if (pos >= max) {\n      return -1;\n    }\n\n    ch = state.src.charCodeAt(pos++);\n\n    if (ch >= 0x30\n    /* 0 */\n    && ch <= 0x39\n    /* 9 */\n    ) {\n      continue;\n    } // found valid marker\n\n\n    if (ch === 0x29\n    /* ) */\n    || ch === 0x2e\n    /* . */\n    ) {\n      break;\n    }\n\n    return -1;\n  }\n\n  if (pos < max && state.src.charCodeAt(pos) !== 0x20\n  /* space */\n  ) {\n    // \" 1.test \" - is not a list item\n    return -1;\n  }\n\n  return pos;\n}\n\nfunction markTightParagraphs(state, idx) {\n  var i,\n      l,\n      level = state.level + 2;\n\n  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n      state.tokens[i + 2].tight = true;\n      state.tokens[i].tight = true;\n      i += 2;\n    }\n  }\n}\n\nmodule.exports = function list(state, startLine, endLine, silent) {\n  var nextLine,\n      indent,\n      oldTShift,\n      oldIndent,\n      oldTight,\n      oldParentType,\n      start,\n      posAfterMarker,\n      max,\n      indentAfterMarker,\n      markerValue,\n      markerCharCode,\n      isOrdered,\n      contentStart,\n      listTokIdx,\n      prevEmptyEnd,\n      listLines,\n      itemLines,\n      tight = true,\n      terminatorRules,\n      i,\n      l,\n      terminate; // Detect list type and position after marker\n\n  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {\n    isOrdered = true;\n  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {\n    isOrdered = false;\n  } else {\n    return false;\n  }\n\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  } // We should terminate list on style change. Remember first one to compare.\n\n\n  markerCharCode = state.src.charCodeAt(posAfterMarker - 1); // For validation mode we can terminate immediately\n\n  if (silent) {\n    return true;\n  } // Start list\n\n\n  listTokIdx = state.tokens.length;\n\n  if (isOrdered) {\n    start = state.bMarks[startLine] + state.tShift[startLine];\n    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));\n    state.tokens.push({\n      type: 'ordered_list_open',\n      order: markerValue,\n      lines: listLines = [startLine, 0],\n      level: state.level++\n    });\n  } else {\n    state.tokens.push({\n      type: 'bullet_list_open',\n      lines: listLines = [startLine, 0],\n      level: state.level++\n    });\n  } //\n  // Iterate list items\n  //\n\n\n  nextLine = startLine;\n  prevEmptyEnd = false;\n  terminatorRules = state.parser.ruler.getRules('list');\n\n  while (nextLine < endLine) {\n    contentStart = state.skipSpaces(posAfterMarker);\n    max = state.eMarks[nextLine];\n\n    if (contentStart >= max) {\n      // trimming space in \"-    \\n  3\" case, indent is 1 here\n      indentAfterMarker = 1;\n    } else {\n      indentAfterMarker = contentStart - posAfterMarker;\n    } // If we have more than 4 spaces, the indent is 1\n    // (the rest is just indented code block)\n\n\n    if (indentAfterMarker > 4) {\n      indentAfterMarker = 1;\n    } // If indent is less than 1, assume that it's one, example:\n    //  \"-\\n  test\"\n\n\n    if (indentAfterMarker < 1) {\n      indentAfterMarker = 1;\n    } // \"  -  test\"\n    //  ^^^^^ - calculating total length of this thing\n\n\n    indent = posAfterMarker - state.bMarks[nextLine] + indentAfterMarker; // Run subparser & write tokens\n\n    state.tokens.push({\n      type: 'list_item_open',\n      lines: itemLines = [startLine, 0],\n      level: state.level++\n    });\n    oldIndent = state.blkIndent;\n    oldTight = state.tight;\n    oldTShift = state.tShift[startLine];\n    oldParentType = state.parentType;\n    state.tShift[startLine] = contentStart - state.bMarks[startLine];\n    state.blkIndent = indent;\n    state.tight = true;\n    state.parentType = 'list';\n    state.parser.tokenize(state, startLine, endLine, true); // If any of list item is tight, mark list as tight\n\n    if (!state.tight || prevEmptyEnd) {\n      tight = false;\n    } // Item become loose if finish with empty line,\n    // but we should filter last element, because it means list finish\n\n\n    prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);\n    state.blkIndent = oldIndent;\n    state.tShift[startLine] = oldTShift;\n    state.tight = oldTight;\n    state.parentType = oldParentType;\n    state.tokens.push({\n      type: 'list_item_close',\n      level: --state.level\n    });\n    nextLine = startLine = state.line;\n    itemLines[1] = nextLine;\n    contentStart = state.bMarks[startLine];\n\n    if (nextLine >= endLine) {\n      break;\n    }\n\n    if (state.isEmpty(nextLine)) {\n      break;\n    } //\n    // Try to check if list is terminated or continued.\n    //\n\n\n    if (state.tShift[nextLine] < state.blkIndent) {\n      break;\n    } // fail if terminating block found\n\n\n    terminate = false;\n\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n\n    if (terminate) {\n      break;\n    } // fail if list has another type\n\n\n    if (isOrdered) {\n      posAfterMarker = skipOrderedListMarker(state, nextLine);\n\n      if (posAfterMarker < 0) {\n        break;\n      }\n    } else {\n      posAfterMarker = skipBulletListMarker(state, nextLine);\n\n      if (posAfterMarker < 0) {\n        break;\n      }\n    }\n\n    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {\n      break;\n    }\n  } // Finilize list\n\n\n  state.tokens.push({\n    type: isOrdered ? 'ordered_list_close' : 'bullet_list_close',\n    level: --state.level\n  });\n  listLines[1] = nextLine;\n  state.line = nextLine; // mark paragraphs tight if needed\n\n  if (tight) {\n    markTightParagraphs(state, listTokIdx);\n  }\n\n  return true;\n};","map":{"version":3,"names":["skipBulletListMarker","state","startLine","marker","pos","max","bMarks","tShift","eMarks","src","charCodeAt","skipOrderedListMarker","ch","markTightParagraphs","idx","i","l","level","tokens","length","type","tight","module","exports","list","endLine","silent","nextLine","indent","oldTShift","oldIndent","oldTight","oldParentType","start","posAfterMarker","indentAfterMarker","markerValue","markerCharCode","isOrdered","contentStart","listTokIdx","prevEmptyEnd","listLines","itemLines","terminatorRules","terminate","options","maxNesting","Number","substr","push","order","lines","parser","ruler","getRules","skipSpaces","blkIndent","parentType","tokenize","line","isEmpty"],"sources":["C:/Users/caoma/Downloads/another/online-shop/node_modules/remarkable/lib/rules_block/list.js"],"sourcesContent":["// Lists\n\n'use strict';\n\n\n// Search `[-+*][\\n ]`, returns next pos arter marker on success\n// or -1 on fail.\nfunction skipBulletListMarker(state, startLine) {\n  var marker, pos, max;\n\n  pos = state.bMarks[startLine] + state.tShift[startLine];\n  max = state.eMarks[startLine];\n\n  if (pos >= max) { return -1; }\n\n  marker = state.src.charCodeAt(pos++);\n  // Check bullet\n  if (marker !== 0x2A/* * */ &&\n      marker !== 0x2D/* - */ &&\n      marker !== 0x2B/* + */) {\n    return -1;\n  }\n\n  if (pos < max && state.src.charCodeAt(pos) !== 0x20) {\n    // \" 1.test \" - is not a list item\n    return -1;\n  }\n\n  return pos;\n}\n\n// Search `\\d+[.)][\\n ]`, returns next pos arter marker on success\n// or -1 on fail.\nfunction skipOrderedListMarker(state, startLine) {\n  var ch,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  if (pos + 1 >= max) { return -1; }\n\n  ch = state.src.charCodeAt(pos++);\n\n  if (ch < 0x30/* 0 */ || ch > 0x39/* 9 */) { return -1; }\n\n  for (;;) {\n    // EOL -> fail\n    if (pos >= max) { return -1; }\n\n    ch = state.src.charCodeAt(pos++);\n\n    if (ch >= 0x30/* 0 */ && ch <= 0x39/* 9 */) {\n      continue;\n    }\n\n    // found valid marker\n    if (ch === 0x29/* ) */ || ch === 0x2e/* . */) {\n      break;\n    }\n\n    return -1;\n  }\n\n\n  if (pos < max && state.src.charCodeAt(pos) !== 0x20/* space */) {\n    // \" 1.test \" - is not a list item\n    return -1;\n  }\n  return pos;\n}\n\nfunction markTightParagraphs(state, idx) {\n  var i, l,\n      level = state.level + 2;\n\n  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n      state.tokens[i + 2].tight = true;\n      state.tokens[i].tight = true;\n      i += 2;\n    }\n  }\n}\n\n\nmodule.exports = function list(state, startLine, endLine, silent) {\n  var nextLine,\n      indent,\n      oldTShift,\n      oldIndent,\n      oldTight,\n      oldParentType,\n      start,\n      posAfterMarker,\n      max,\n      indentAfterMarker,\n      markerValue,\n      markerCharCode,\n      isOrdered,\n      contentStart,\n      listTokIdx,\n      prevEmptyEnd,\n      listLines,\n      itemLines,\n      tight = true,\n      terminatorRules,\n      i, l, terminate;\n\n  // Detect list type and position after marker\n  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {\n    isOrdered = true;\n  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {\n    isOrdered = false;\n  } else {\n    return false;\n  }\n\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  // We should terminate list on style change. Remember first one to compare.\n  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);\n\n  // For validation mode we can terminate immediately\n  if (silent) { return true; }\n\n  // Start list\n  listTokIdx = state.tokens.length;\n\n  if (isOrdered) {\n    start = state.bMarks[startLine] + state.tShift[startLine];\n    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));\n\n    state.tokens.push({\n      type: 'ordered_list_open',\n      order: markerValue,\n      lines: listLines = [ startLine, 0 ],\n      level: state.level++\n    });\n\n  } else {\n    state.tokens.push({\n      type: 'bullet_list_open',\n      lines: listLines = [ startLine, 0 ],\n      level: state.level++\n    });\n  }\n\n  //\n  // Iterate list items\n  //\n\n  nextLine = startLine;\n  prevEmptyEnd = false;\n  terminatorRules = state.parser.ruler.getRules('list');\n\n  while (nextLine < endLine) {\n    contentStart = state.skipSpaces(posAfterMarker);\n    max = state.eMarks[nextLine];\n\n    if (contentStart >= max) {\n      // trimming space in \"-    \\n  3\" case, indent is 1 here\n      indentAfterMarker = 1;\n    } else {\n      indentAfterMarker = contentStart - posAfterMarker;\n    }\n\n    // If we have more than 4 spaces, the indent is 1\n    // (the rest is just indented code block)\n    if (indentAfterMarker > 4) { indentAfterMarker = 1; }\n\n    // If indent is less than 1, assume that it's one, example:\n    //  \"-\\n  test\"\n    if (indentAfterMarker < 1) { indentAfterMarker = 1; }\n\n    // \"  -  test\"\n    //  ^^^^^ - calculating total length of this thing\n    indent = (posAfterMarker - state.bMarks[nextLine]) + indentAfterMarker;\n\n    // Run subparser & write tokens\n    state.tokens.push({\n      type: 'list_item_open',\n      lines: itemLines = [ startLine, 0 ],\n      level: state.level++\n    });\n\n    oldIndent = state.blkIndent;\n    oldTight = state.tight;\n    oldTShift = state.tShift[startLine];\n    oldParentType = state.parentType;\n    state.tShift[startLine] = contentStart - state.bMarks[startLine];\n    state.blkIndent = indent;\n    state.tight = true;\n    state.parentType = 'list';\n\n    state.parser.tokenize(state, startLine, endLine, true);\n\n    // If any of list item is tight, mark list as tight\n    if (!state.tight || prevEmptyEnd) {\n      tight = false;\n    }\n    // Item become loose if finish with empty line,\n    // but we should filter last element, because it means list finish\n    prevEmptyEnd = (state.line - startLine) > 1 && state.isEmpty(state.line - 1);\n\n    state.blkIndent = oldIndent;\n    state.tShift[startLine] = oldTShift;\n    state.tight = oldTight;\n    state.parentType = oldParentType;\n\n    state.tokens.push({\n      type: 'list_item_close',\n      level: --state.level\n    });\n\n    nextLine = startLine = state.line;\n    itemLines[1] = nextLine;\n    contentStart = state.bMarks[startLine];\n\n    if (nextLine >= endLine) { break; }\n\n    if (state.isEmpty(nextLine)) {\n      break;\n    }\n\n    //\n    // Try to check if list is terminated or continued.\n    //\n    if (state.tShift[nextLine] < state.blkIndent) { break; }\n\n    // fail if terminating block found\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n\n    // fail if list has another type\n    if (isOrdered) {\n      posAfterMarker = skipOrderedListMarker(state, nextLine);\n      if (posAfterMarker < 0) { break; }\n    } else {\n      posAfterMarker = skipBulletListMarker(state, nextLine);\n      if (posAfterMarker < 0) { break; }\n    }\n\n    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) { break; }\n  }\n\n  // Finilize list\n  state.tokens.push({\n    type: isOrdered ? 'ordered_list_close' : 'bullet_list_close',\n    level: --state.level\n  });\n  listLines[1] = nextLine;\n\n  state.line = nextLine;\n\n  // mark paragraphs tight if needed\n  if (tight) {\n    markTightParagraphs(state, listTokIdx);\n  }\n\n  return true;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}