{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nimport resolvePathname from 'resolve-pathname';\nimport valueEqual from 'value-equal';\nimport { parsePath } from './PathUtils';\nexport var createLocation = function createLocation(path, state, key, currentLocation) {\n  var location = void 0;\n\n  if (typeof path === 'string') {\n    // Two-arg form: push(path, state)\n    location = parsePath(path);\n    location.state = state;\n  } else {\n    // One-arg form: push(location)\n    location = _extends({}, path);\n    if (location.pathname === undefined) location.pathname = '';\n\n    if (location.search) {\n      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;\n    } else {\n      location.search = '';\n    }\n\n    if (location.hash) {\n      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;\n    } else {\n      location.hash = '';\n    }\n\n    if (state !== undefined && location.state === undefined) location.state = state;\n  }\n\n  try {\n    location.pathname = decodeURI(location.pathname);\n  } catch (e) {\n    if (e instanceof URIError) {\n      throw new URIError('Pathname \"' + location.pathname + '\" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');\n    } else {\n      throw e;\n    }\n  }\n\n  if (key) location.key = key;\n\n  if (currentLocation) {\n    // Resolve incomplete/relative pathname relative to current location.\n    if (!location.pathname) {\n      location.pathname = currentLocation.pathname;\n    } else if (location.pathname.charAt(0) !== '/') {\n      location.pathname = resolvePathname(location.pathname, currentLocation.pathname);\n    }\n  } else {\n    // When there is no prior location and pathname is empty, set it to /\n    if (!location.pathname) {\n      location.pathname = '/';\n    }\n  }\n\n  return location;\n};\nexport var locationsAreEqual = function locationsAreEqual(a, b) {\n  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && valueEqual(a.state, b.state);\n};","map":{"version":3,"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","resolvePathname","valueEqual","parsePath","createLocation","path","state","currentLocation","location","pathname","undefined","search","charAt","hash","decodeURI","e","URIError","locationsAreEqual","a","b"],"sources":["C:/Users/caoma/Downloads/another/online-shop/node_modules/history/es/LocationUtils.js"],"sourcesContent":["var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nimport resolvePathname from 'resolve-pathname';\nimport valueEqual from 'value-equal';\nimport { parsePath } from './PathUtils';\n\nexport var createLocation = function createLocation(path, state, key, currentLocation) {\n  var location = void 0;\n  if (typeof path === 'string') {\n    // Two-arg form: push(path, state)\n    location = parsePath(path);\n    location.state = state;\n  } else {\n    // One-arg form: push(location)\n    location = _extends({}, path);\n\n    if (location.pathname === undefined) location.pathname = '';\n\n    if (location.search) {\n      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;\n    } else {\n      location.search = '';\n    }\n\n    if (location.hash) {\n      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;\n    } else {\n      location.hash = '';\n    }\n\n    if (state !== undefined && location.state === undefined) location.state = state;\n  }\n\n  try {\n    location.pathname = decodeURI(location.pathname);\n  } catch (e) {\n    if (e instanceof URIError) {\n      throw new URIError('Pathname \"' + location.pathname + '\" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');\n    } else {\n      throw e;\n    }\n  }\n\n  if (key) location.key = key;\n\n  if (currentLocation) {\n    // Resolve incomplete/relative pathname relative to current location.\n    if (!location.pathname) {\n      location.pathname = currentLocation.pathname;\n    } else if (location.pathname.charAt(0) !== '/') {\n      location.pathname = resolvePathname(location.pathname, currentLocation.pathname);\n    }\n  } else {\n    // When there is no prior location and pathname is empty, set it to /\n    if (!location.pathname) {\n      location.pathname = '/';\n    }\n  }\n\n  return location;\n};\n\nexport var locationsAreEqual = function locationsAreEqual(a, b) {\n  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && valueEqual(a.state, b.state);\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}